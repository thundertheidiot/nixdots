#+TITLE: GNU/Emacs
#+STARTUP: overview
#+PROPERTY: header-args:emacs-lisp :tangle yes :results none

https://protesilaos.com/codelog/2024-11-28-basic-emacs-configuration/

Setup use-package

#+begin_src emacs-lisp
(require 'use-package)
(require 'general)

;; wrong place lo 
;; (add-to-list 'default-frame-alist '(alpha-background . 0.88))

(require 'use-package-ensure)
(setq use-package-always-ensure t)

(use-package diminish
  :demand t
  :config
  (diminish 'font-lock-mode)
  (diminish 'visual-line-mode)
  (diminish 'auto-revert-mode)
  (diminish 'eldoc-mode))
#+end_src

* Libraries

These are used somewhere later, but don't require any configuration.

#+begin_src emacs-lisp
(use-package pcre2el)
(use-package dash)
(use-package plz)
#+end_src


* Basic settings

** Cleanup

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backup-files" user-emacs-directory))))

(let ((auto-save-dir (expand-file-name "auto-saves/" user-emacs-directory)))
  (unless (file-directory-p auto-save-dir)
    (make-directory auto-save-dir))
  (setq auto-save-list-file-prefix auto-save-dir
	auto-save-file-name-transforms `((".*" ,auto-save-dir t))))

(setq create-lockfiles nil)
#+end_src

** General stuff

#+begin_src emacs-lisp
(add-function :after after-focus-change-function
	      (defun th/garbage-collect ()
		(unless (frame-focus-state)
		  (garbage-collect))))

(setq use-short-answers t
      native-comp-async-report-warnings-errors 'silent
      indent-tabs-mode t
      c-basic-offset 'tab-width
      tab-width 4
      gc-cons-threshold (* 8 1024 1024)
      read-process-output-max (* 1024 1024)

      ring-bell-function 'ignore ;; i hate that stupid bell

      inhibit-startup-screen t
      inhibit-splash-screen t

      display-line-numbers-type 'relative

      backward-delete-char-untabify-method nil)

(electric-indent-mode)
(electric-pair-mode)

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(global-display-line-numbers-mode 1)
(global-visual-line-mode t)
(savehist-mode 1)

(defun advice!-keyboard-escape-quit-adv (fun)
  "Around advice for `keyboard-escape-quit' FUN.
Preserve window configuration when pressing ESC."
  (let ((buffer-quit-function (or buffer-quit-function #'ignore)))
    (funcall fun)))
(advice-add #'keyboard-escape-quit :around #'advice!-keyboard-escape-quit-adv)

(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "ESC") 'keyboard-escape-quit)
#+end_src

#+begin_src emacs-lisp
(recentf-mode)
(setq recentf-max-menu-items 1000
      recentf-max-saved-items 1000)
(run-at-time "5 min" 300 'recentf-save-list)
#+end_src

This is here for my weird keyboards, due to their sizes, i don't have a separate grave key, instead i use (a modified) QK_GESC, where pressing shift + escape sends ~, and super + escape sends `.

#+begin_src emacs-lisp
(global-set-key (kbd "s-`") #'(lambda () (interactive) (insert "`")))
#+end_src

** Fonts

Using the default system fonts (for now).

#+begin_src emacs-lisp
(set-face-attribute 'default nil
		    :family "Monospace"
		    :height 90
		    :weight 'regular)

(set-face-attribute 'variable-pitch nil
		    :font "Sans-Serif"
		    :height 120
		    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
		    :font "Monospace"
		    :weight 'medium)

(set-face-attribute 'font-lock-comment-face nil
		    :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil
		    :slant 'italic)

(add-to-list 'default-frame-alist '(font . "Monospace"))

(setq-default line-spacing 0.12)
#+end_src

** Some settings related to scrolling? 

#+begin_src emacs-lisp
(setq scroll-conservatively 10)
(setq scroll-margin 7)
(setq pixel-scroll-precision-large-scroll-height 40.0)
(setq pixel-scroll-precision-use-momentum t)
#+end_src


* Window configuration system

System to allow saving and loading arbitrary arrangements of buffers easily.

This may or may not be necessary somewhere, i don't remember.

#+begin_src emacs-lisp
(use-package subr-x :ensure nil)
#+end_src

#+begin_src emacs-lisp
(defvar saved-window-configurations '())

(defun wcs--format-window-list ()
  (let ((window-list-string-formatted) (value))
    (dolist (window (window-list) value)
      (setq window-list-string-formatted (concat
					  window-list-string-formatted
					  (format "%s, " (buffer-name (window-buffer window))))))
    (setq window-list-string-formatted (string-remove-suffix ", " window-list-string-formatted))
    window-list-string-formatted))

(defun save-window-configuration (&optional name)
  "Add the current window configuration to saved window configurations, if NAME is provided, give it a name."
  (interactive "P")
  (when (and name (not (stringp name)))
    (setq name (completing-read "Name wcfg: " '())))
  (add-to-list 'saved-window-configurations `(,(or name
						   (if (string= (projectile-project-name) "-")
						       (format "%s (%s)"
							       (shell-command-to-string "date \"+%a %R\"")
							       (wcs--format-window-list))
						     (format "%s: %s (%s)"
							     (projectile-project-name)
							     (shell-command-to-string "date \"+%a %R\"")
							     (wcs--format-window-list))))
					      . ,(window-state-get (frame-root-window) t))))

(defun new-window-configuration ()
  "Save the current window configuration close other buffers."
  (interactive)
  (save-window-configuration)
  (select-window (split-window))
  (delete-other-windows))

(defun load-window-configuration ()
  "Select a window configuration from the list and load it."
  (interactive)
  (let ((config (cdr
		 (assoc
		  (completing-read "Select window config: " saved-window-configurations)
		  saved-window-configurations))))
    (when config
	(window-state-put config (frame-root-window) t))))

(defun delete-window-configuration ()
  "Select a window configuration to delete."
  (interactive)
  (setq saved-window-configurations
	(delq (assoc
	       (completing-read "Delete a window configuration: "
				saved-window-configurations)
	       saved-window-configurations)
	      saved-window-configurations)))
#+end_src


* Misc functions

This is defined here so i can hook it easily.

#+begin_src emacs-lisp
(defun th/turn-off-line-numbers ()
  "Turn off line numbers 🤯"
  (display-line-numbers-mode 0))
#+end_src

Function to make mode keymaps easier, there's no real point to this.

#+begin_src emacs-lisp
(defun make-mode-keymap (map outer)
  (mapc (lambda (inner)
	  (define-key map (kbd (car inner)) (cdr inner)))
	outer))
#+end_src

This is bound to =gc= in normal mode

#+begin_src emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "If a region is selected, either uncomment or comment it, if not, uncomment or comment the current line."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))
#+end_src

This is bound to =SPC er=

#+begin_src emacs-lisp
(defun eval-region-and-go-to-normal-mode ()
  "Evaluate elisp in the selected region and go back to normal mode."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (eval-region beg end)
    (evil-normal-state)))
#+end_src

Intelligently split windows

#+begin_src emacs-lisp
(defun th/intelligent-split (&optional force)
  (interactive)
  (let ((width (window-total-width))
	(height (window-total-height)))
    (cond ((and (< width 140) (< height 40) (not force)) (current-buffer))
	  ((> (+ 10 (* 2 height)) width) (split-window-below))
	  (t (split-window-right)))))
#+end_src

* Keybinding

** Evil mode and prerequisites

Undo system for evil mode, i don't really have a point for using undo-tree specifically, but it looked cool so i picked it.

#+begin_src emacs-lisp
(use-package undo-tree
  :demand t
  :diminish undo-tree-mode
  :diminish global-undo-tree-mode
  :custom
  (undo-tree-auto-save-history t)
  (undo-tree-history-directory-alist `((,(rx (* nonl)) . ,(expand-file-name "undo-tree/" user-emacs-directory))))
  :config
  ;; redefine this so i can override the default undo binding
  (defun undo-tree-overridden-undo-bindings-p () 
    nil)
  (global-undo-tree-mode)
  (unless (file-directory-p (expand-file-name "undo-tree/" user-emacs-directory))
    (make-directory (expand-file-name "undo-tree/" user-emacs-directory))))
#+end_src

Vi(m) bindings in emacs

#+begin_src emacs-lisp
(use-package evil
  :after undo-tree
  :demand t
  :custom
  (evil-want-integration t)
  (evil-want-keybinding nil)
  (evil-vsplit-window-right t)
  (evil-split-window-below t)
  (evil-want-minibuffer t) ;; we're going extra evil
  (evil-undo-system 'undo-tree)
  :config
  (evil-set-undo-system evil-undo-system)
  (evil-mode))
#+end_src

** Evil mode improvements

Collection of evil-like bindings for other modes.

#+begin_src emacs-lisp
(use-package evil-collection
  :demand t
  :after evil
  :diminish evil-collection-unimpaired-mode
  :config
  (evil-collection-init '(apropos
			  calc
			  compile
			  comint
			  dashboard
			  debug
			  ediff
			  emoji
			  eshell
			  woman
			  pdf
			  org
			  proced
			  dired
			  elfeed
			  wdired
			  image
			  ibuffer
			  simple-mpc
			  magit
			  magit-todos
			  vdiff
			  sly
			  wgrep
			  yaml-mode
			  diff-hl
			  vterm)))
#+end_src

j and k go down visual lines, not real lines

#+begin_src emacs-lisp
(use-package evil-better-visual-line
  :demand t
  :after evil
  :config
  (evil-better-visual-line-on))
#+end_src

** general.el

Which key

#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :diminish which-key-mode
  :config
  (which-key-setup-side-window-bottom)
  (which-key-mode))
#+end_src

#+begin_src emacs-lisp
(use-package general
  :demand t
  :config
  (general-evil-setup))

;; (general-create-definer th/leader
;;   :states '(normal insert visual emacs motion)
;;   :keymaps 'override
;;   :prefix "SPC"
;;   :global-prefix "C-SPC")

;; (general-create-definer th/local
;;   :states '(normal insert visual emacs motion)
;;   :keymaps 'override
;;   :prefix "SPC l"
;;   :global-prefix "C-SPC l")

(general-def :keymaps 'override
  "M-x" 'execute-extended-command)

(general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
  "w" '(:ignore t :wk "window")
  "wh" '("move left" . windmove-left)
  "wj" '("move down" . windmove-down)
  "wk" '("move up" . windmove-up)
  "wl" '("move right" . windmove-right)
  "<left>" '("move left" . windmove-left)
  "<down>" '("move down" . windmove-down)
  "<up>" '("move up" . windmove-up)
  "<right>" '("move right" . windmove-right)
  "wq" '("close" . evil-quit)
  "ww" '("close" . evil-quit)
  "ws" '("horizontal split" . (lambda () (interactive) (th/intelligent-split t)))

  "wc" '(:ignore t :wk "window configurations")
  "wcl" '("load" . load-window-configuration)
  "wcs" '("save" . save-window-configuration)
  "wcn" '("new" . new-window-configuration)
  
  "H" '("increase window width" . (lambda () (interactive) (evil-window-increase-width 2)))
  "J" '("increase window height" . (lambda () (interactive) (evil-window-increase-height 2)))
  
  "l" '(:ignore t :wk "local (mode specific)")
  "s" '(:ignore t :wk "search")

  "d" '("dired" . (lambda () (interactive)
                    (when default-directory
                      (select-window (th/intelligent-split t))
                      (dired default-directory))))

  "D" '("dired in current window" . (lambda () (interactive)
				      (when default-directory
					(dired default-directory))))

  "o" '(:ignore t :wk "open")

  ":" '("M-x" . execute-extended-command)
  ";" '("M-x" . execute-extended-command)
  "." '("find file" . find-file)
  ">" '("find file from ~/" . (lambda () (interactive) (find-file (getenv "HOME"))))
  
  "h" '(:ignore t :wk "help")
  "hb" '("describe binding" . describe-bindings)
  "hf" '("describe function" . describe-function)
  "hv" '("describe variable" . describe-variable)
  "hF" '("describe face" . describe-face)
  "hk" '("describe key" . describe-key)
  "ha" '("describe" . apropos)
  
  "b" '(:ignore t :wk "buffer")
  "bi" '("ibuffer" . ibuffer)
  "bK" '("kill buffer" . kill-buffer)
  "bk" '("kill this buffer" . kill-current-buffer)

  "e" '(:ignore t :wk "emacs")
  "ec" '("async shell command" . async-shell-command)
  "er" '("eval region or line" . eval-region-and-go-to-normal-mode)
  "eb" '("eval buffer" . eval-buffer)
  "ee" '("eval expression" . eval-expression))

(general-define-key
 :states '(normal visual)
 "gc" 'comment-or-uncomment-region-or-line
 "<up>" 'enlarge-window
 "<left>" 'shrink-window-horizontally
 "<right>" 'enlarge-window-horizontally
 "<down>" 'shrink-window
 ";" 'evil-ex
 "M-k" 'enlarge-window
 "M-h" 'shrink-window-horizontally
 "M-l" 'enlarge-window-horizontally
 "M-j" 'shrink-window

 "C-j" #'backward-sexp
 "C-k" #'forward-sexp
 "C-d" #'kill-sexp
 )

(general-define-key
 "C-=" 'text-scale-increase
 "C--" 'text-scale-decrease
 "C-j" nil
 "<escape>" #'keyboard-quit
 "<escape>" #'keyboard-escape-quit
 "ESC" #'keyboard-quit
 "ESC" #'keyboard-escape-quit
 "<C-wheel-up>" 'text-scale-increase
 "<C-wheel-down>" 'text-scale-decrease)
#+end_src

WIP window navigation mode

#+begin_src emacs-lisp :tangle no
(defvar window-navigation-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "h") 'windmove-left)
    (define-key map (kbd "j") 'windmove-down)
    (define-key map (kbd "k") 'windmove-up)
    (define-key map (kbd "l") 'windmove-right)
    (define-key map (kbd "<escape>") 'window-navigation-mode)
    map)
  "Keymap for `my-windmove-mode'.")

(evil-make-overriding-map window-navigation-mode-map 'normal)
(evil-make-overriding-map window-navigation-mode-map)

(define-minor-mode window-navigation-mode
  "A minor mode for using hjkl to move between windows."
  :global t
  :lighter " WindMove"
  :keymap window-navigation-mode-map)

#+end_src

* Org mode

** Org itself

#+begin_src emacs-lisp :tangle no
(defun th/agenda-category ()
  (let* ((file-name (when buffer-file-name
		      (file-name-sans-extension
		       (file-name-nondirectory))))
	 (title (org-get-title))
	 (category (org-get-category)))
    (or (if (and
	     title
	     (string= category file-name))
	    title
	  category)
	"")))
#+end_src

#+begin_src emacs-lisp
(use-package org
  :demand t
  :mode ("\\.org\\'" . org-mode)
  :diminish org-indent-mode
  :custom
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively t)
  (org-startup-with-inline-images t)
  (calendar-week-start-day 1)
  (org-babel-load-languages '((emacs-lisp . t)
			      (shell . t)
			      (eshell . t)
			      (lisp . t)))
  :init
  (add-hook 'org-mode-hook #'org-indent-mode)
  (add-hook 'org-mode-hook (lambda () (electric-indent-local-mode -1)))
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "oa" '("org agenda" . org-agenda))
  :general-config
  (:keymaps 'org-mode-map
	    "C-j" nil)
  (:states '(normal visual motion) :keymaps 'org-mode-map :prefix "SPC l"
	   "l" '(:ignore t :wk "org link")
	   "li" '("insert org link" . org-insert-link)
	   "lo" '("open org link" . org-open-at-point)
	   "le" '("open org link" . org-edit-special)
	   "lt" '("toggle link display" . org-toggle-link-display))
  (:keymaps 'org-mode-map :states '(normal visual motion)
	    "RET" (lambda () (interactive)
		    (unless (ignore-errors (org-open-at-point))
		      (evil-ret)))))
#+end_src

** Org roam

Note taking

#+begin_src emacs-lisp
(use-package org-roam
  :custom
  (org-roam-directory (file-truename "~/Documents/org/roam"))
  (org-agenda-files (org-roam-list-files))
  :config
  (unless (file-directory-p org-roam-directory)
    (make-directory org-roam-directory))
  (org-roam-db-autosync-mode)
  (org-roam-setup)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "r" '(:ignore t :wk "roam")
	   "rb" '("buffer" . org-roam-buffer-toggle)
	   "rf" '("find node" . org-roam-node-find)
	   "rI" '("create id" . org-id-get-create)
	   "ri" '("insert node" . org-roam-node-insert)))
#+end_src

** Org download

Allow easily inserting images

#+begin_src emacs-lisp
(use-package org-download
  :hook (dired-mode . org-download-enable)
  :custom (org-download-screenshot-method "grim -g \"$(slurp)\" -t png %s")
  :general
  (:states '(normal visual motion) :keymaps 'org-mode-map :prefix "SPC l"
	   "s" '("screenshot" . org-download-screenshot)
	   "c" '("image from clipboard" . org-download-clipboard)))
#+end_src

** Org tempo

Faster inserting of templates like the source code blocks here.

#+begin_src emacs-lisp
(defun th/org-tempo-electric-pair-fix ()
  (setq-local electric-pair-inhibit-predicate
	      `(lambda (c)
		 (if (char-equal c ?<)
		     t
		   (,electric-pair-inhibit-predicate c)))))

(use-package org-tempo
  :demand t
  :ensure nil ;; included with org
  :after org
  :hook (org-mode . th/org-tempo-electric-pair-fix)
  :custom
  (org-structure-template-alist '(("el" . "src emacs-lisp"))))
#+end_src

** Org bullets

#+begin_src emacs-lisp
(use-package org-bullets
  :diminish org-bullets-mode
  :hook (org-mode . org-bullets-mode))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :diminish olivetti-mode
  :custom 
  (olivetti-min-body-width 50)
  (olivetti-body-width 80)
  (olivetti-style 'fancy)
  (olivetti-margin-width 12)
  :config
  (set-face-attribute 'olivetti-fringe nil :background "#313244")
  :hook
  (olivetti-mode-on . (lambda () (olivetti-set-width olivetti-body-width)))
  (org-mode . olivetti-mode))
#+end_src

* IDE

** Project management

*** Git

#+begin_src emacs-lisp
(use-package magit
  :custom
  (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  (magit-auto-revert-mode nil)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "g" '(:ignore t :wk "git")
	   "gg" '("open magit" . magit-status)
	   "gd" '(:ignore t :wk "diff")
	   "gdu" '("diff unstaged" . magit-diff-unstaged)
	   "gds" '("diff staged" . magit-diff-staged)
	   "gc" '("commit" . magit-commit)
	   "gp" '("push" . magit-push)
	   "gF" '("push" . magit-pull)))
#+end_src

Show added/deleted/edited parts in the fringe

#+begin_src emacs-lisp
(defun th/last-diff-hl-hunk (&optional backward)
  "Go to the last hunk in the file, first if BACKWARD is t."
  (while-let ((pos (diff-hl-search-next-hunk backward)))
    (goto-char (overlay-start pos))))

(defun advice!diff-hl-next-hunk-loop-around (orig-fun &rest args)
  (let ((backward (if (car args)
		      nil
		    t)) ;; flip
	(return (ignore-errors (funcall orig-fun args)))) 
    (unless return
      (th/last-diff-hl-hunk backward)
      (message "Looped around"))))

(use-package diff-hl
  :demand t
  :diminish diff-hl-mode
  :custom
  (diff-hl-show-staged-changes nil)
  :config
  (advice-add 'diff-hl-next-hunk :around #'advice!diff-hl-next-hunk-loop-around)
  (global-diff-hl-mode +1)
  (mapc (lambda (f) 
	  (set-face-background f "green")
	  (set-face-foreground f "green"))
	'(diff-hl-insert diff-hl-dired-insert diff-hl-margin-insert))
  (mapc (lambda (f) 
	  (set-face-background f "purple")
	  (set-face-foreground f "purple"))
	'(diff-hl-change diff-hl-dired-change diff-hl-margin-change))
  (mapc (lambda (f) 
	  (set-face-background f "red")
	  (set-face-foreground f "red"))
	'(diff-hl-delete diff-hl-dired-delete diff-hl-margin-delete))
  :hook
  (magit-pre-refresh . diff-hl-magit-pre-refresh)
  (magit-post-refresh . diff-hl-magit-post-refresh)
  (olivetti-mode . diff-hl-margin-mode)
  (dired-mode . diff-hl-dired-mode)
  (diff-hl-mode . diff-hl-flydiff-mode)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "ga" '("stage hunk" . diff-hl-stage-current-hunk)
	   "gr" '("revert hunk" . diff-hl-revert-hunk)
	   "gn" '("next hunk" . diff-hl-next-hunk)
	   "gN" '("previous hunk" . diff-hl-previous-hunk)))
#+end_src

Git timemachine lets you browse through the history of a file tracked by git

#+begin_src emacs-lisp
(use-package git-timemachine
  :general-config
  (:states 'normal :keymaps 'git-timemachine-mode-map
	   "<" 'git-timemachine-show-previous-revision
	   "J" 'git-timemachine-show-previous-revision
	   ">" 'git-timemachine-show-next-revision
	   "K" 'git-timemachine-show-next-revision
	   "i" nil ;; no point in going to insert mode, the buffer is read only
	   "C-f" (lambda () (git-timemachine-show-nth-revision 1))
	   "C-g" 'git-timemachine-show-nth-revision
	   "C-c" 'git-timemachine-show-current-revision)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "gt" '("timemachine" . git-timemachine-toggle)))
#+end_src

#+begin_src emacs-lisp
(use-package emsg-blame
  :demand t
  :config
  (global-emsg-blame-mode t))
#+end_src

*** Projectile

Projectile is a project management tool for emacs

#+begin_src emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :commands (projectile-run-eshell projectile-run-vterm)
  :custom
  (projectile-switch-project-action #'projectile-dired)
  :config
  (projectile-mode)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "P" '(:keymap projectile-command-map :package projectile)
	   "p" '(:ignore t :package projectile :wk "project")
	   "pp" '("switch project" . projectile-switch-project)
	   "ps" '("search project" . (lambda () (interactive) (consult-ripgrep (projectile-project-root))))
	   "p." '("find project file" . projectile-find-file)
	   "po" '(:ignore t :wk "open")
	   "pog" '("project version control (git)" . projectile-vc)
	   "pb" '("switch buffer in project" . projectile-switch-to-buffer)))
#+end_src

Sort ibuffer by project

#+begin_src emacs-lisp
(use-package ibuffer-projectile
  :hook
  (ibuffer-mode . (lambda () (ibuffer-projectile-set-filter-groups)
		    (unless (eq ibuffer-sorting-mode 'alphabetic)
		      (ibuffer-do-sort-by-alphabetic)))))
#+end_src

*** TODO

Highlight the following keywords in code

- =TODO=
- =HACK=
- =FIXME=

#+begin_src emacs-lisp
(use-package hl-todo
  :demand t
  :diminish hl-todo-mode
  :diminish global-hl-todo-mode
  :custom
  (hl-todo-keyword-faces '(("TODO" . "#cc9393")
			   ("HACK" . "#d0bf8f")
			   ("NOTE" . "#cc9393")
			   ("FIXME" . "#cc9393")))
  :config
  (global-hl-todo-mode 1))
#+end_src

Index those keywords inside magit.

#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :hook (magit-mode . magit-todos-mode)
  :config (magit-todos-mode 1))
#+end_src

** Lsp

#+begin_src emacs-lisp
(use-package eglot
  :commands eglot-ensure
  :custom
  (eglot-autoshutdown t)
  (eglot-events-buffer-size 0)
  (eglot-sync-connect nil)
  (eglot-connect-timeout nil)
  :config
  (fset #'jsonrpc--log-event #'ignore)
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "c" '(:ignore t :wk "code")
	   "ca" '("code actions" . (lambda () (interactive)
				     (eglot-code-actions 1 (point-max) nil t)))))
#+end_src

#+begin_src emacs-lisp
(use-package eglot-booster
  :demand t
  :after eglot
  :config (eglot-booster-mode))
#+end_src

** Debug

#+begin_src emacs-lisp :tangle no
(use-package dape
  :defer t
  :hook
  (eglot-managed-mode . dape-modesave)
  (kill-emacs . dape-breakpoint-save)
  (after-init . dape-breakpoint-load)
  :custom
  (dape-inlay-hints t)
  ;; :config
  ;; (dape-breakpoint-global-mode)
  )
#+end_src

** Errors

#+begin_src emacs-lisp
(use-package flycheck
  :hook
  (prog-mode . flycheck-mode)
  (eglot-managed-mode . flycheck-mode)
  ;; :config 
  ;; (global-flycheck-mode)
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "cn" '("next error" . flycheck-next-error)
	   "cN" '("previous error" . flycheck-previous-error)))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck-eglot
  :demand t
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
#+end_src

** Formatting

#+begin_src emacs-lisp
(use-package apheleia
  :demand t
  :diminish apheleia
  :config
  (setf (alist-get 'nixfmt apheleia-formatters)
	'("alejandra"))
  ;; (setf (alist-get 'ocamlformat apheleia-formatters)
  ;; 	'("ocamlformat" "-" "--name" filepath "--enable-outside-detected-project" "--no-break-sequences"))
  (apheleia-global-mode +1))
#+end_src

** Completion

#+begin_src emacs-lisp
(use-package corfu
  :demand t
  :custom
  (corfu-auto t)
  (corfu-auto-delay 0.18)
  (corfu-cycle t)
  :hook
  (after-init . global-corfu-mode)
  :general-config
  (:states '(insert)
	   "C-j" nil
	   "C-k" nil)
  (:states '(normal visual insert) :keymaps 'corfu-mode-map
	   "C-j" nil
	   "C-k" nil
	   "C-i" nil)
  (:keymaps 'corfu-map
	    "RET" nil
	    "<up>" nil
	    "<down>" nil
	    "M-i" (lambda () (interactive) 
		    (let ((current-prefix-arg t))
		      (call-interactively #'corfu-info-documentation)))
	    "C-j" #'corfu-next
	    "C-k" #'corfu-previous
	    "S-RET" #'corfu-complete
	    "S-<return>" #'corfu-complete))
#+end_src

** Languages

Language specific setup

*** Rust

#+begin_src emacs-lisp :tangle @lang_rust@
(use-package rustic
  :diminish rustic-mode
  :mode ("\\.rs\\'" . rustic-mode)
  :hook (rustic-mode . eglot-ensure)
  :init
  (setq rustic-lsp-client 'eglot
	rustic-use-rust-save-some-buffers t
	compilation-ask-about-save nil))
#+end_src

*** Nix

#+begin_src emacs-lisp :tangle @lang_nix@
(use-package nix-mode
  :mode "\\.nix\\'"
  :hook (nix-mode . eglot-ensure))
#+end_src

*** Haskell

#+begin_src emacs-lisp :tangle @lang_haskell@
(use-package haskell-mode
  :mode "\\.hs\\'"
  :hook (haskell-mode . eglot-ensure))
;; TODO: try haskell-ts-mode
;; (use-package haskell-ts-mode
;;   :mode "\\.hs\\'"
;;   :config (haskell-ts-setup-eglot))
#+end_src

*** Type/JavaScript

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode "\\.tsx?\\'")

;; (use-package tsi
;;   :after tree-sitter
;;   :hook
;;   (typescript-mode . tsi-typescript-mode)
;;   (css-mode . tsi-css-mode)
;;   (scss-mode . tsi-scss-mode)
;;   (json-mode . tsi-json-mode))
#+end_src

*** Lua

#+begin_src emacs-lisp :tangle @lang_lua@
(use-package lua-mode
  :mode "\\.lua\\'"
  :hook (lua-mode . eglot-ensure))
#+end_src

*** Gdscript/godot

#+begin_src emacs-lisp
(use-package gdscript-mode
  :mode "\\.gdscript\\'"
  :hook (gdscript-mode . eglot-ensure))

(use-package glsl-mode)
(use-package gdshader-mode)
#+end_src

*** C#

#+begin_src emacs-lisp
(use-package csharp-mode
  :require nil ;; comes with emacs
  :mode "\\.cs\\'"
  :hook
  (csharp-mode . eglot-ensure)
  (csharp-mode . csharp-ts-mode))
#+end_src

*** Elisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'corfu-mode)
#+end_src

** Misc nice things

*** Puni

#+begin_src emacs-lisp
(use-package puni
  :config
  (puni-global-mode)
  :general-config
  (:states '(normal visual) :keymaps 'override))
#+end_src

*** Smartparens

Smartparens-mode allows you to use parenthesis and some other characters more easily.
??

#+begin_src emacs-lisp
;; (use-package smartparens
;;   :demand t
;;   :diminish smartparens-mode
;;   :config
;;   (smartparens-global-mode)
;;   :general-config
;;   (:states '(normal visual) :keymaps 'override
;; 	   "C-h" #'sp-backward-sexp
;; 	   "C-k" #'sp-up-sexp
;; 	   "C-j" #'sp-down-sexp
;; 	   "C-l" #'sp-next-sexp
;; 	   "C-y" #'sp-copy-sexp
;; 	   )
;;   )

;; (use-package evil-smartparens
;;   :hook (smartparens-enabled . evil-smartparens-mode))
#+end_src

*** Rainbow delimeters

Rainbow delimiters gives colors to delimiters like parenthesis, which helps with seeing where you are at, especially in lisp land.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :diminish rainbow-delimiters-mode
  :hook
  (prog-mode . rainbow-delimiters-mode)
  (org-mode . rainbow-delimiters-mode))
#+end_src

Envrc loads environment variables from direnv for use in any buffer. This combined with nix-direnv allows you to automatically enter a nix-shell by just being in the correct directory, which is incredibly useful for developement on nixos.

#+begin_src emacs-lisp
(use-package envrc
  :demand t
  :hook (after-init . envrc-global-mode))

;; (use-package inheritenv
;;   :config
;;   (inheritenv-add-advice 'shell-command-to-string))
#+end_src


* AI

** GPTEL

#+begin_src emacs-lisp
  (use-package gptel
    :config
    (setq gptel-backend (gptel-make-gh-copilot "Copilot"))
    (add-to-list 'gptel-tools
		 (gptel-make-tool
		  :function (lambda (query)
			      (with-temp-message (format "Searching for: `%s`" query)
				(let ((url (format "http://127.0.0.1:8080/search?q=%s&format=json"
						   (url-hexify-string query))))
				  (with-temp-buffer
				    (url-insert-file-contents url)
				    (let ((json-response (json-read)))
				      (mapconcat (lambda (result)
						   (format "%s - %s\n%s" (cdr (assoc 'title result)) (cdr (assoc 'url result)) (cdr (assoc 'content result))))
						 (cdr (assoc 'results json-response))
						 "\n\n"))))))
		  :name "search_web"
		  :description "Searches the web using SearXNG metasearch engine and returns formatted results including titles, URLs, and content excerpts."
		  :args (list
			 '(:name "query"
				 :type string
				 :description "The search query to execute against the search engine."))
		  :category "web"
		  :include t)))
#+end_src

* Terminals 

** Vterm

Vterm is a full fledged terminal emulator inside emacs, it should work with any terminal application.

#+begin_src emacs-lisp
(defun th/vterm (&optional projectile)
  (if projectile
      (projectile-run-vterm t)
    (vterm t))
  (end-of-buffer)
  (evil-append-line 1))

(use-package vterm
  :hook (vterm-mode . th/turn-off-line-numbers)
  :commands (vterm)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "ov" '((lambda () (interactive)
		    (select-window (th/intelligent-split t))
		    (th/vterm)) :wk "vterm")
	   "oV" '((lambda () (interactive)
		    (th/vterm)) :wk "vterm in this window")
	   "pov" '((lambda () (interactive)
		     (select-window (th/intelligent-split t))
		     (th/vterm t)) :wk "vterm")
	   "poV" '((lambda () (interactive)
		     (th/vterm t)) :wk "vterm in this window")))
#+end_src

A fun hack to fix vterm evil-mode interactions from [[https://github.com/akermu/emacs-libvterm/issues/313#issuecomment-738842507][this issue comment]].

#+begin_src emacs-lisp
(defun vterm-evil-insert ()
  (interactive)
  (vterm-goto-char (point))
  (call-interactively #'evil-insert))

(defun vterm-evil-append ()
  (interactive)
  (vterm-goto-char (1+ (point)))
  (call-interactively #'evil-append))

(defun vterm-evil-delete ()
  "Provide similar behavior as `evil-delete'."
  (interactive)
  (let ((inhibit-read-only t)
        )
    (cl-letf (((symbol-function #'delete-region) #'vterm-delete-region))
      (call-interactively 'evil-delete))))

(defun vterm-evil-change ()
  "Provide similar behavior as `evil-change'."
  (interactive)
  (let ((inhibit-read-only t))
    (cl-letf (((symbol-function #'delete-region) #'vterm-delete-region))
      (call-interactively 'evil-change))))

(general-def :states '(normal) :keymaps 'vterm-mode-map
  "a" 'vterm-evil-append
  "d" 'vterm-evil-delete
  "i" 'vterm-evil-insert
  "c" 'vterm-evil-change)
#+end_src

#+begin_src emacs-lisp
(use-package eshell-vterm
  :demand t
  :after eshell
  :config 
  (eshell-vterm-mode))
#+end_src

** Eshell

Eshell is a built in shell, with support for normal system commands, and emacs lisp expressions. It is very powerful and extensible.

Fish-completion allows eshell to use completions from fish.

#+begin_src emacs-lisp
(use-package fish-completion)
#+end_src

Eshell itself

#+begin_src emacs-lisp
(defun th/eshell (&optional projectile &rest args)
  (if projectile
      (projectile-run-eshell t)
    (eshell t))
  (end-of-buffer)
  (evil-append-line 1))

(use-package eshell
  :ensure nil
  :after (fish-completion)
  :commands (eshell projectile-run-eshell)
  :custom
  (eshell-history-size 10000000)
  :config
  (add-to-list 'eshell-modules-list 'eshell-elecslash)
  (add-to-list 'eshell-modules-list 'eshell-tramp)

  (setq eshell-visual-commands '("nix"
				 "nix-build"
				 "nixos-rebuild"
				 "nh"
				 "deploy"
				 "btop"
				 "htop"))
  :hook
  (eshell-mode . th/turn-off-line-numbers)
  (eshell-mode . fish-completion-mode)
  :general-config
  (:states '(normal visual) :keymaps 'eshell-mode-map
	   "A" (lambda () (interactive) (end-of-buffer) (evil-append-line 1)))
  (:states '(normal visual insert) :keymaps 'eshell-mode-map
	   "C->" (lambda () (interactive) 
		   (insert (concat "> #<buffer " (read-buffer "Send to: ") ">")))
	   "C-p" (lambda () (interactive)
		   (insert (read-file-name "Insert path: "))))
  (:keymaps 'eshell-mode-map :states '(normal visual motion)
	    "RET" (lambda () (interactive)
		    (unless (ignore-errors (browse-url))
		      (evil-ret))))
  :general
  (:states '(normal visual insert emacs motion) :prefix "SPC" :keymaps 'override :global-prefix "C-SPC"
	   "oe" '("eshell" . (lambda () (interactive) 
			       (select-window (th/intelligent-split t)) 
			       (th/eshell)))
	   "oE" '("eshell in this window" . (lambda () (interactive) (th/eshell)))
	   "poe" '("eshell" . (lambda () (interactive) 
				(select-window (th/intelligent-split t))
				(th/eshell t)))
	   "poE" '("eshell in new window" . (lambda () (interactive) (th/eshell t)))))
#+end_src

#+RESULTS:

Aliases and functions

#+begin_src emacs-lisp
(defun eshell/v (&rest args)
  (select-window (th/intelligent-split t))
  (apply 'eshell-exec-visual args))

(defalias 'eshell/V 'eshell-exec-visual)

(defun eshell/c ()
  (eshell/cd
   (read-file-name "Change directory: ")))

(defvar eshell-nix-shell-active nil
  "Show <nix-shell> in the eshell prompt.")

(defun th/eshell-prompt ()
  (concat
   (if eshell-nix-shell-active
       (propertize "<nix-shell> " 'face '(:foreground "green"))
     "")
   (abbreviate-file-name (eshell/pwd))
   
   (if (magit-toplevel)
       (propertize (format "  %s" (magit-get-current-branch)) 'face '(:foreground "#cba6f7"))
     "")

   (propertize " λ" 'face
	       (if (string-match (rx
				  "/sudo:root"
				  (* nonl))
				 (eshell/pwd))
		   '(:foreground "red")
		 '(:foreground "purple")))
   (propertize " " 'face
	       'default)))

(setq eshell-prompt-function #'th/eshell-prompt)
(setq eshell-prompt-regexp
      (rx line-start
	  (*?
	   nonl)
	  "λ "))

;; (setq eshell-banner-message
;;       (let ((os (with-temp-buffer
;; 		  (insert-file-contents "/etc/os-release")
;; 		  (goto-char (point-min))
;; 		  (re-search-forward "PRETTY_NAME=\"\\(.*\\)\"")
;; 		  (match-string 1))))
;; 	(concat os "\n\n")))

(defun eshell/nix-shell (&rest args)
  (if (member "--run" args)
      (eshell-command-result
       (concat "*nix-shell " (mapconcat 'identity args " ")))
    (let* ((output (shell-command-to-string
		    (format "nix-shell %s --run \"env\""
			    (mapconcat 'identity args " "))))
	   (lines (split-string output "\n" t))
	   (environment (mapcar (lambda (line)
				  (s-split-up-to "=" line 1))
				lines)))
      (dolist (env environment)
	(when (= 2 (length env))
	  (if (string= (car env) "PATH")
	      (eshell-set-path (cadr env))
	    (ignore-errors
	      (eshell-set-variable (car env) (cadr env))))
	  
	  (setq-local eshell-nix-shell-active t))))))

(defmacro re (&rest rx-sexp) ;; Stolen from https://youtube.com/watch?v=9xLeqwl_7n0
  "Convert rx expression RX-SEXP to pcre compatible regexp."
  `(rxt-elisp-to-pcre (rx ,@rx-sexp)))

(defalias 'eshell/less 'view-file)
#+end_src

For some reason advice-add didn't seem to function, so this just manually replicates eshell/exit.

#+begin_src emacs-lisp
(defun eshell/exit ()
  (evil-quit)
  (throw 'eshell-terminal t))
(defalias 'eshell/e 'eshell/exit)
#+end_src

* Polymode

#+begin_src emacs-lisp :tangle no
(use-package polymode
  :config
  (define-hostmode poly-rustic-hostmode :mode 'rustic-mode)
  
  (define-innermode poly-sql-rustic-innermode
    :mode 'sql-mode
    :head-matcher (rx 
		   "sqlx::query"
		   (opt "_as")
		   "!("
		   (* anything)
		   "\"")
    :tail-matcher (rx "\"")
    :head-mode 'host
    :tail-mode 'host)

  (add-to-list 'polymode-move-these-minor-modes-from-old-buffer 'olivetti-mode)
  (add-to-list 'polymode-move-these-vars-from-old-buffer 'olivetti-body-width)

  (define-polymode poly-sql-rustic-mode
    :hostmode 'poly-rustic-hostmode
    :innermodes '(poly-sql-rustic-innermode)))

(use-package poly-org)
#+end_src

* Misc stuff

** Vertico, consult, orderless and marginalia

#+begin_src emacs-lisp
(use-package vertico
  :demand t
  :custom
  (vertico-resize t)
  (vertico-cycle t)
  :general-config
  ;; evil-want-minibuffer t
  (:keymaps 'vertico-map :states '(normal visual)
	    "j" #'vertico-next
	    "k" #'vertico-previous
	    "gg" #'vertico-first
	    "G" #'vertico-last)
  (:keymaps 'vertico-map :states '(normal visual insert)
	    "RET" #'vertico-exit
	    "C-u" #'vertico-quick-exit
	    "C-j" #'vertico-next
	    "C-k" #'vertico-previous
	    "C-l" #'vertico-quick-jump)
  (:keymaps 'vertico-map :states '(insert)
	    "<backspace>" #'vertico-directory-delete-char
	    "DEL" #'vertico-directory-delete-char)
  (:keymaps 'override :states '(normal visual insert)
	    "C-c c" #'vertico-buffer-mode)
  :config
  (vertico-mode))
#+end_src

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :custom
  (consult-preview-excluded-buffers '(major-mode . exwm-mode))
  (consult-line-start-from-top nil)
  :general-config
  ;; (:states '(normal visual)
  ;; 	   "/" #'evil-search-forward
  ;; 	   "?" #'evil-search-backward
  ;; "C-/" #'evil-search-forward
  ;; "C-?" #'evil-search-backward
  ;; )
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "sg" '("grep" . (lambda () (interactive)
			     (consult-ripgrep (expand-file-name ""))))
	   "f" '("recent file" . consult-recent-file)
	   "sf" '("find" . consult-fd)
	   "si" '("imenu" . consult-imenu)
	   "bs" '("switch" . consult-buffer)
	   "bo" '("open buffer in new window" (lambda () (interactive)
						(select-window (th/intelligent-split t))
						(consult-buffer)))
	   ))

(defun advice!-consult-exwm-preview-fix (&rest _args)
  "Kludge to stop EXWM buffers from stealing focus during Consult previews."
  (when (derived-mode-p 'exwm-mode)
    (when-let ((mini (active-minibuffer-window)))
      (select-window (active-minibuffer-window)))))

(advice-add
 #'consult--buffer-preview :after #'advice!-consult-exwm-preview-fix)
#+end_src

Save grep search into evil search history.

#+begin_src emacs-lisp
(defun advice!-consult-grep-evil-search-history (ret)
  "Add the selected item to the evil search history."
  (when ret ;; return value is nil if you quit early
    (let ((search (if (string= (substring (car consult--grep-history) 0 1) "#")
		      (substring (car consult--grep-history) 1 nil)
		    (car consult--grep-history))))
      (add-to-history 'regexp-search-ring search)
      (add-to-history 'evil-ex-search-history search)
      (setq evil-ex-search-pattern (list search t t))
      (setq evil-ex-search-direction 'forward))
    ret))
(advice-add 'consult--grep :filter-return #'advice!-consult-grep-evil-search-history)

(defun advice!-consult-line-evil-search-history (ret)
  "Add the selected item to the evil search history."
  (when ret ;; return value is nil if you quit early
    (let ((search (car consult--line-history)))
      (add-to-history 'regexp-search-ring search)
      (add-to-history 'evil-ex-search-history search)
      (setq evil-ex-search-pattern (list search t t))
      (setq evil-ex-search-direction 'forward))
    ret))
(advice-add 'consult-line :filter-return #'advice!-consult-line-evil-search-history)
#+end_src

#+begin_src emacs-lisp
(use-package wgrep)
#+end_src

#+begin_src emacs-lisp
(use-package embark
  ;; :after wgrep
  :demand t
  :general-config
  (
   "C-;" #'embark-act
   "C-a" #'embark-select))

(use-package embark-consult
  :after embark
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

#+begin_src emacs-lisp
(use-package orderless
  :demand t
  :after (vertico consult)
  :custom
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :demand t
  :config
  (marginalia-mode))
#+end_src

#+begin_src emacs-lisp
(defun advice!-crm-indicator (args)
  (cons (format "[CRM%s] %s"
		(replace-regexp-in-string
		 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		 crm-separator)
		(car args))
	(cdr args)))
(advice-add #'completing-read-multiple :filter-args #'advice!-crm-indicator)

(setq minibuffer-prompt-properties '(read-only t cursor-intangible-mode t face minibuffer-prompt)
      enable-recursive-minibuffers t)

(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Media playback "inside" emacs

#+begin_src emacs-lisp
(general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
  "m" '(:ignore t :wk "media"))
#+end_src

Control mpd from emacs

#+begin_src emacs-lisp
(use-package simple-mpc
  :demand t
  :hook (simple-mpc-mode . th/turn-off-line-numbers)
  :custom
  (simple-mpc-volume-step-size 3)
  ;; :general
  ;; (:states '(normal visual motion) :keymaps 'override :prefix "SPC" 
  ;;   "m" '(:ignore t :wk "media")
  ;;   "mm" '("open simple-mpc" . simple-mpc)
  ;;   "ms" '("search" . simple-mpc-query)
  ;;   "mp" '("play/pause" . simple-mpc-toggle)
  ;;   "mC" '("clear" . simple-mpc-clear-current-playlist)
  ;;   "mP" '("playlist" . simple-mpc-view-current-playlist)
  ;;   "ma" '("load playlist" . simple-mpc-load-playlist)
  ;;   "mh" '("prev" . simple-mpc-prev)
  ;;   "ml" '("next" . simple-mpc-next)))
  )
#+end_src

Control an mpv instance inside emacs

#+begin_src emacs-lisp
(use-package empv
  :demand t
  :general-config
  (:keymaps 'empv-youtube-results-mode :states '(normal visual insert)
	    "RET" 'empv-youtube-results-play-current)
  :init 
  (setq empv-invidious-instance "https://yewtu.be/api/v1")
  (setq empv-volume-step 3)
  (setq empv-radio-channels '(("nowhere.moe Cyberia" . "https://radio.nowhere.moe/radio/cyberia.mp3")
			      ("nowhere.moe Focus" . "https://radio.nowhere.moe/radio/focus.mp3")
			      ("nowhere.moe Nihilism" . "https://radio.nowhere.moe/radio/nihilism.mp3")
			      ("nowhere.moe Psychedelia" . "https://radio.nowhere.moe/radio/psychedelia.mp3"))))

(defun eshell/yt (&rest args)
  (empv-youtube (mapconcat (lambda (s) (format "%s " s)) args)))
#+end_src

Custom menus with transient

#+begin_src emacs-lisp
(use-package transient)

;; (defun media-menu--empv-remove-playlist-item ()
;;   (interactive)
;;   (empv--playlist-select-item-and
;;    (empv-playlist-remove item)))

(transient-define-prefix empv-menu ()
  "Transient menu for empv."
  [["Menu"
    ("q" "Quit" transient-quit-one)]
   ["Playback"
    ("p" "Toggle" empv-toggle :transient t)
    ("v" "Toggle Video" empv-toggle-video :transient t)

    ("j" "Previous" empv-playlist-prev :transient t)
    ("k" "Next" empv-playlist-next :transient t)

    ("x" "Close MPV" empv-exit :transient t)]
   ["Playlist"
    ("Y" "Search Youtube" empv-youtube)
    ("f" "Play File" empv-play-file)
    ("s" "Select From Playlist" empv-playlist-select)]
   ["Settings"
    ("y" "Toggle Single" empv-toggle-file-loop :transient t)
    ("r" "Toggle Repeat" empv-toggle-playlist-loop :transient t)
    
    ("-" "Volume Down" empv-volume-down :transient t)
    ("=" "Volume Up" empv-volume-up :transient t)]])

(transient-define-prefix mpd-menu ()
  "Transient menu for empv."
  [["Menu"
    ("q" "Quit" transient-quit-one)]
   ["Playback"
    ("p" "Toggle" simple-mpc-toggle :transient t)
    
    ("j" "Previous" simple-mpc-prev :transient t)
    ("k" "Next" simple-mpc-next :transient t)]
   ["Playlist"
    ("l" "Load playlist" simple-mpc-load-playlist :transient t)
    ("s" "Search" simple-mpc-query)
    
    ("c" "View playlist" simple-mpc-view-current-playlist)
    ("C" "Clear playlist" simple-mpc-clear-current-playlist :transient t)]
   ["Settings"
    ("y" "Toggle Single" (lambda () (interactive)
			   (simple-mpc-call-mpc nil "single")) :transient t)
    ("r" "Toggle Repeat" simple-mpc-toggle-repeat :transient t)

    ("-" "Volume Down" simple-mpc-decrease-volume :transient t)
    ("=" "Volume Up" simple-mpc-increase-volume :transient t)]])

(defmacro media-menu--mpv-or-mpd-action (mpv mpd &optional mpv-args mpd-args)
  "If the mpv playlist is not empty, call MPV, else call MPD.
MPV is called with MPV-ARGS and MPD is called with MPD-ARGS."
  `(empv--send-command
    '("get_property_string" "playlist")
    (lambda (result)
      (if (> (length (json-parse-string result)) 0)
	  (apply ,mpv ,mpv-args)
	(apply ,mpd ,mpd-args)))))

(defun media-menu--toggle ()
  (interactive)
  (media-menu--mpv-or-mpd-action #'empv-toggle #'simple-mpc-toggle))

(defun media-menu--volume-increase()
  (interactive)
  (media-menu--mpv-or-mpd-action #'empv-volume-up #'simple-mpc-increase-volume))

(defun media-menu--volume-decrease()
  (interactive)
  (media-menu--mpv-or-mpd-action #'empv-volume-down #'simple-mpc-decrease-volume))

(transient-define-prefix media-menu ()
  "Transient menu for simple-mpc and empv."
  [["Menu"
    ("q" "Quit" transient-quit-one)
    ("e" "Open MPV menu" empv-menu)
    ("m" "Open MPD menu" mpd-menu)]
   ["Playback"
    ("p" "toggle playback" media-menu--toggle :transient t)
    ("p" "toggle playback" media-menu--toggle :transient t)
    ]
   ["Settings"
    ("-" "Volume down" media-menu--volume-decrease :transient t)
    ("=" "Volume up" media-menu--volume-increase :transient t)]])

(general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC" 
  "m" '("media menu" . media-menu))
#+end_src

** Separedit

Separedit allows you to edit a part of a buffer in another buffer, and use another major mode that way, a bit like org src blocks, but worse.

#+begin_src emacs-lisp
(use-package separedit)
#+end_src

** Ultra scroll

#+begin_src emacs-lisp
(use-package ultra-scroll
  :init
  (setq scroll-conservatively 101 ; important!
        scroll-margin 0) 
  :config
  (ultra-scroll-mode 1))
#+end_src

** Fix/improve some emacs stuff

*** Tramp

Tramp doesn't work properly on nixos systems by default, because it doesn't find $PATH

#+begin_src emacs-lisp
(use-package tramp-sh
  :ensure nil ;; part of emacs
  :config
  (setq tramp-remote-path
	(append tramp-remote-path
 		'(tramp-own-remote-path))))
#+end_src

*** Dired

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :demand t
  :hook (dired-mode . hl-line-mode)
  :hook (dired-mode . auto-revert-mode)
  :init
  (setq dired-mouse-drag t)
  :general-config
  (:keymaps 'dired-mode-map :states '(normal insert visual motion)
	    "SPC" nil
	    "q" 'evil-quit
	    "<backspace>" 'dired-up-directory
	    "C-<return>" (lambda () (interactive) (empv-play (dired-get-filename))))
  (:keymaps 'dired-mode-map :states '(normal visual motion) :prefix "SPC"
	    "oe" '("eshell in this window" . (lambda () (interactive) (th/eshell))))
  :config
  (setq dired-listing-switches "-alh")
  (setq dired-mouse-drag t)
  (unless (display-graphic-p)
    (general-def dired-mode-map "DEL" 'dired-up-directory)))
#+end_src

#+begin_src emacs-lisp
(use-package dired-du)
#+end_src

Casual dired has magit-like menus for dired commands

#+begin_src emacs-lisp :tangle no
(use-package casual-dired
  :general
  (:keymaps dired-mode-map
	    "C-o" 'casual-dired-tmenu))
#+end_src

#+begin_src emacs-lisp
(use-package openwith
  :custom
  (openwith-associations `((,(rx nonl (or ".mkv"
					  ".mp4"
					  ".mov"
					  ".webm"))
			    . ("mpv" (file)))
			   ))
  :config
  (openwith-mode))
#+end_src

* Theming

This function will only execute a given function on the first server frame creation.

#+begin_src emacs-lisp
(defvar th/first-server-frame-created nil)
(defun th--unless-first-server-frame-created (func)
  (unless th/first-server-frame-created
    (funcall func)
    (setq th/first-server-frame-created t)))
#+end_src

*** Catppuccin

#+begin_src emacs-lisp
(use-package catppuccin-theme
  :init
  (setq catppuccin-flavor 'mocha)
  :hook
  (after-init . catppuccin-reload)
  (server-after-make-frame . (lambda () (when (display-graphic-p)
					  (th--unless-first-server-frame-created 'catppuccin-reload)))))
#+end_src

*** Solaire

Solaire mode darkens "lesser" buffers like eshell or magit

#+begin_src emacs-lisp
(use-package solaire-mode
  :hook
  (after-init . (lambda ()
		  (when (display-graphic-p) (solaire-global-mode +1))))
  (server-after-make-frame . (lambda ()
			       (when (display-graphic-p) (solaire-global-mode +1)))))
#+end_src

** Nyan mode

#+begin_src emacs-lisp
(use-package nyan-mode
  :custom
  (nyan-animate-nyancat t)
  (nyan-wavy-trail t))
#+end_src

** Mode line

#+begin_src emacs-lisp
(defun th/mode-line ()
  (dolist (face '(mode-line mode-line-active mode-line-inactive))
    (setf (alist-get face solaire-mode-remap-alist) nil))

  (let* ((flavor (alist-get catppuccin-flavor catppuccin-flavor-alist))
	 (color (alist-get 'text flavor)))
    (set-face-attribute 'mode-line-active nil :inherit 'mode-line-inactive :foreground color))
  
  (let ((vpad 10))
    (mapc (lambda (face)
	    (set-face-attribute face nil
				:box `(:line-width (1 . ,vpad) :color ,(face-background face nil t) :style nil)
				:height 110))
	  '(mode-line-active mode-line-inactive)))

  (setq mode-line-format nil)
  (kill-local-variable 'mode-line-format)
  (force-mode-line-update)

  (let* ((flavor (alist-get catppuccin-flavor catppuccin-flavor-alist))
	 (text (alist-get 'text flavor))
	 (green (alist-get 'green flavor))
	 (red (alist-get 'red flavor))
	 (yellow (alist-get 'yellow flavor))
	 (rosewater (alist-get 'rosewater flavor))
	 (mauve (alist-get 'mauve flavor))

	 (envrc-none (propertize "" 'face `(:foreground ,text)))
	 (envrc-on (propertize (propertize "" 'face `(:foreground ,green))))
	 (envrc-error (propertize "" 'face `(:foreground ,red)))
	 )
    (setq-default mode-line-format
		  `(
		    "   "
		    (:eval
		     (propertize "%b" 'face 'bold))
		    "   L%l   " ;; line number

		    ;; (:eval
		    ;;  (when (file-remote-p default-directory)
		    ;;    (let* ((vec (tramp-dissect-file-name default-directory))
		    ;; 	      (user (or (tramp-file-name-user vec) ""))
		    ;; 	      (host (tramp-file-name-host vec)))
		    ;; 	 (propertize (format "%s@%s   " user host) 'face ,(list 'quote (list :foreground rosewater))))))

		    (:eval
		     (pcase envrc--status
		       ('none ,envrc-none)
		       ('on ,envrc-on)
		       (_ ,envrc-error)))

		    "   "
		    
		    (:eval
		     (when (magit-toplevel)
		       (propertize (format "  %s" (magit-get-current-branch)) 'face ,(list 'quote (list :foreground mauve)))
		       ))
		    
		    (:eval (when (magit-toplevel) "   "))

		    (:eval
		     (when eglot--managed-mode
		       (eglot--mode-line-format)))

		    (:eval (when eglot--managed-mode "   "))
		    
		    (:eval
		     (when flycheck-mode
		       (if (eq flycheck-last-status-change 'finished)
			   (let-alist (flycheck-count-errors flycheck-current-errors)
			     (concat
			      (when (and (not .error) (not .warning:?) (not .warning))
				(propertize "" 'face ,(list 'quote (list :foreground green))))
			      (when .error
				(propertize (format " %s" .error) 'face ,(list 'quote (list :foreground red))))
			      (when (or .warning:? .warning)
				(propertize (format "%s %s" (if .error " " "") (+ (or .warning:? 0) (or .warning 0))) 'face ,(list 'quote (list :foreground yellow))))
			      )
			     ))
		       ))
		    
		    (:eval (when flycheck-mode "   "))

		    "%="
		    (:eval (nyan-create)))))
  
  ;; (nyan-start-animation)
  )

(add-hook 'window-setup-hook #'th/mode-line)
(add-hook 'server-after-make-frame-hook #'th/mode-line)
#+end_src

** All the icons

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

https://github.com/jdtsmith/kind-icon

#+begin_src emacs-lisp
(use-package kind-icon
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

*** Dired

#+begin_src emacs-lisp
(defun th--ati-dired ()
  (when (display-graphic-p)
    (th--unless-first-server-frame-created
     (lambda () (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)))))
(use-package all-the-icons-dired
  :after all-the-icons
  :diminish all-the-icons-dired-mode
  :hook (dired-mode . (lambda ()
			(when (display-graphic-p)
			  (all-the-icons-dired-mode)))))
#+end_src

*** Ibuffer

#+begin_src emacs-lisp
(defun th--ati-ibuffer ()
  (when (display-graphic-p)
    (th--unless-first-server-frame-created
     (lambda () (add-hook 'ibuffer-mode-hook #'all-the-icons-ibuffer-mode)))))
(use-package all-the-icons-ibuffer
  :after all-the-icons
  :diminish all-the-icons-ibuffer-mode
  :hook (ibuffer-mode . (lambda ()
			  (when (display-graphic-p)
			    (all-the-icons-ibuffer-mode)))))
#+end_src

* EXWM

#+begin_src emacs-lisp :tangle @exwm_enable@
(use-package dmenu
  :demand t)

;; custom package by me, defined in default.nix
;; allows for per monitor workspaces to be bound to mod+1-9, like on dwm
(use-package dwm-workspaces
  :demand t)

(use-package exwm
  :demand t)

(use-package exwm-firefox-evil
  :config
  (add-hook 'exwm-manage-finish-hook #'exwm-firefox-evil-activate-if-firefox))

(when (and (getenv "EMACS_ENABLE_EXWM") (executable-find "wmctrl"))
  (unless (eq (call-process "wmctrl" nil nil nil "-m") 0)
    (progn
      (require 'exwm-randr)
      (require 'exwm-systemtray)
      (require 'exwm-xim)

      (dwm-workspaces--init)

      (defun th/exwm-shell-cmd (command) (start-process-shell-command (car (split-string command " ")) nil command))

      (defun th/keyboard-layout ()
	(interactive)
	(let* ((output (shell-command-to-string "setxkbmap -query"))
	       (layout (nth 2 (split-string output "\n"))))
	  (if (string-match-p "us" layout)
	      (shell-command-to-string "setxkbmap fi")
	    (shell-command-to-string "setxkbmap us"))))

      (mapc 'th/exwm-shell-cmd
	    '("xset r rate 300 50"
	      "dbus-update-activation-environment --verbose --systemd DBUS_SESSION_BUS_ADDRESS DISPLAY XAUTHORITY &"
	      "gnome-keyring-daemon"))

      (when (file-directory-p "/sys/class/power_supply/BAT0/")
	(display-battery-mode))

      (setq display-time-format "%H:%M:%S - %d %b %Y (%a)"
	    display-time-default-load-average nil

	    mouse-autoselect-window t
	    focus-follow-mouse t

	    exwm-input-line-mode-passthrough t
	    exwm-workspace-show-all-buffers t)
      (display-time-mode 1)

      (dolist (k `(
                   escape
                   ))
        (cl-pushnew k exwm-input-prefix-keys))

      
      (defun advice!-exwm-input--on-ButtonPress-line-mode (buffer button-event)
	"Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
	(with-current-buffer buffer
	  (let ((read-event (exwm-input--mimic-read-event button-event)))
	    (exwm--log "%s" read-event)
	    (if (and read-event
		     (exwm-input--event-passthrough-p read-event))
		;; The event should be forwarded to emacs
		(progn
		  (exwm-input--cache-event read-event)
		  (exwm-input--unread-event button-event)

		  xcb:Allow:ReplayPointer)
	      ;; The event should be replayed
	      xcb:Allow:ReplayPointer))))

      (advice-add 'exwm-input--on-ButtonPress-line-mode :override #'advice!-exwm-input--on-ButtonPress-line-mode)
      
      (setq exwm-input-global-keys
	    `((,(kbd "s-i") . exwm-input-toggle-keyboard)
	      (,(kbd "s-f") . exwm-layout-toggle-fullscreen)
	      (,(kbd "s-S-F") . exwm-floating-toggle-floating)
	      (,(kbd "s-d") . dmenu)
	      (,(kbd "s-SPC") . th/keyboard-layout)
	      (,(kbd "<XF86AudioPlay>") . simple-mpc-toggle)
	      
	      ;; (,(kbd "M-x") . execute-extended-command)

	      (,(kbd "s-.") . dwm-workspaces--select-previous-monitor)
	      (,(kbd "s-,") . dwm-workspaces--select-next-monitor)

	      (,(kbd "s-1") . (lambda () (interactive) (dwm-workspaces--switch-by-index 1)))
	      (,(kbd "s-2") . (lambda () (interactive) (dwm-workspaces--switch-by-index 2)))
	      (,(kbd "s-3") . (lambda () (interactive) (dwm-workspaces--switch-by-index 3)))
	      (,(kbd "s-4") . (lambda () (interactive) (dwm-workspaces--switch-by-index 4)))
	      (,(kbd "s-5") . (lambda () (interactive) (dwm-workspaces--switch-by-index 5)))
	      (,(kbd "s-6") . (lambda () (interactive) (dwm-workspaces--switch-by-index 6)))
	      (,(kbd "s-7") . (lambda () (interactive) (dwm-workspaces--switch-by-index 7)))
	      (,(kbd "s-8") . (lambda () (interactive) (dwm-workspaces--switch-by-index 8)))
	      (,(kbd "s-9") . (lambda () (interactive) (dwm-workspaces--switch-by-index 9)))

	      ;; (,(kbd "s-!") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 1)))
	      ;; (,(kbd "s-@") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 2)))
	      ;; (,(kbd "s-#") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 3)))
	      ;; (,(kbd "s-$") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 4)))
	      ;; (,(kbd "s-%") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 5)))
	      ;; (,(kbd "s-^") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 6)))
	      ;; (,(kbd "s-&") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 7)))
	      ;; (,(kbd "s-*") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 8)))
	      ;; (,(kbd "s-(") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 9)))

              ;; ,@(mapc (lambda (i)
              ;;           (,(kbd (format "s-%d" i)) .
              ;;            (lambda () (interactive)
              ;;              (dwm-workspaces--switch-by-index ,i))))
              ;;         (number-sequence 1 9))

              ,@(cl-mapcar (lambda (c n)
                             (,(kbd (format "s-%c" c)) .
                              (lambda () (interactive)
                                (dwm-workspaces--move-window-by-index ,n))))
                           '(?! ?@ ?# ?$ ?% ?^ ?& ?* ?\()
                           (number-sequence 1 9))
	      ))
      
      (mapc (lambda (keybind)
	      (global-set-key (car keybind) (cdr keybind)))
	    exwm-input-global-keys)

      ;; https://github.com/minad/corfu/discussions/408
      (defun advice!corfu-make-frame-with-monitor-awareness (func frame x y width height)
	"Advice `corfu--make-frame` to be monitor-aware, adjusting X and Y according to the focused monitor."
	(let* ((workarea (nth exwm-workspace-current-index exwm-workspace--workareas))
	       (mon-x (oref workarea x))
	       (mon-y (oref workarea y)))
	  (funcall func frame (+ mon-x x) (+ mon-y y) width height)))

      (advice-add 'corfu--make-frame :around #'advice!corfu-make-frame-with-monitor-awareness)

      (general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
	"y" '(:ignore t :wk "exwm")
	"yd" '("dmenu" . dmenu)
	"yf" '("toggle floating" . exwm-floating-toggle-floating))

      (general-define-key 
       :states '(normal visual visual replace motion emacs operator-pending)
       :keymaps 'exwm-mode-map
       "<mouse-1>" (lambda () (interactive) (exwm-input--fake-key 'down))
       "<mouse-2>" nil
       "<mouse-3>" nil
       "<down-mouse-1>" nil
       "<down-mouse-2>" nil
       "<down-mouse-3>" nil

       ;; "i" 'exwm-input-release-keyboard
       
       "h" (lambda () (interactive) (exwm-input--fake-key 'left))
       "j" (lambda () (interactive) (exwm-input--fake-key 'down))
       "k" (lambda () (interactive) (exwm-input--fake-key 'up))
       "l" (lambda () (interactive) (exwm-input--fake-key 'right)))

      (setq exwm-workspace-warp-cursor t
	    exwm-layout-show-all-buffers t
	    mouse-autoselect-window t
	    focus-follows-mouse t)

      (setq ibuffer-saved-filter-groups
	    '(("default"
	       ("Process" (mode . comint-mode))
	       )))

      (add-hook 'ibuffer-mode-hook
		(lambda ()
		  (ibuffer-switch-to-saved-filter-groups "default")))

      (add-hook 'exwm-update-class-hook
		(lambda ()
		  (if exwm-class-name
		      (exwm-workspace-rename-buffer exwm-class-name)
		    (exwm-workspace-rename-buffer (generate-new-buffer-name "EXWM - Unknown window")))
		  (exwm-workspace-rename-buffer (format "EXWM - %s" exwm-class-name))))

      (exwm-xim-mode 1)
      (exwm-randr-mode 1)
      (exwm-enable)
      (exwm-systemtray-mode 1))))
#+end_src

* End

# Local Variables:
# olivetti-body-width: 120
# org-confirm-babel-evaluate: nil
# End:
