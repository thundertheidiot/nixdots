#+TITLE: GNU/Emacs
#+STARTUP: overview
#+PROPERTY: header-args:emacs-lisp :tangle yes

Setup use-package

#+begin_src emacs-lisp
(require 'use-package)
(require 'general)

(require 'use-package-ensure)
(setq use-package-always-ensure t)

(use-package diminish
  :demand t
  :config
  (diminish 'font-lock-mode)
  (diminish 'visual-line-mode)
  (diminish 'auto-revert-mode)
  (diminish 'eldoc-mode))
#+end_src

* Libraries

These are used somewhere later, but don't require any configuration.

#+begin_src emacs-lisp
(use-package pcre2el)
(use-package dash)
#+end_src


* Basic settings

** Cleanup

#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "backup-files" user-emacs-directory))))

(let ((auto-save-dir (expand-file-name "auto-saves/" user-emacs-directory)))
  (unless (file-directory-p auto-save-dir)
    (make-directory auto-save-dir))
  (setq auto-save-list-file-prefix auto-save-dir
	auto-save-file-name-transforms `((".*" ,auto-save-dir t))))

(setq create-lockfiles nil)
#+end_src

** General stuff

#+begin_src emacs-lisp
(add-function :after after-focus-change-function
	      (defun th/garbage-collect ()
		(unless (frame-focus-state)
		  (garbage-collect))))

(setq use-short-answers t
      native-comp-async-report-warnings-errors 'silent
      indent-tabs-mode t
      c-basic-offset 'tab-width
      tab-width 4
      gc-cons-threshold (* 8 1024 1024)

      ring-bell-function 'ignore ;; i hate that stupid bell

      inhibit-startup-screen t
      inhibit-splash-screen t

      display-line-numbers-type 'relative

      backward-delete-char-untabify-method nil)

(electric-indent-mode)

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(global-display-line-numbers-mode 1)
(global-visual-line-mode t)
(savehist-mode 1)


(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key (kbd "ESC") 'keyboard-escape-quit)
#+end_src

#+begin_src emacs-lisp
(recentf-mode)
(setq recentf-max-menu-items 100
      recentf-max-saved-items 100)
(run-at-time "5 min" 300 'recentf-save-list)
#+end_src

This is here for my weird keyboards, due to their sizes, i don't have a separate grave key, instead i use (a modified) QK_GESC, where pressing shift + escape sends ~, and super + escape sends `.

#+begin_src emacs-lisp
(global-set-key (kbd "s-`") #'(lambda () (interactive) (insert "`")))
#+end_src

** Fonts

Using the default system fonts (for now).

#+begin_src emacs-lisp
(set-face-attribute 'default nil
		    :family "Monospace"
		    :height 90
		    :weight 'regular)

(set-face-attribute 'variable-pitch nil
		    :font "Sans-Serif"
		    :height 120
		    :weight 'medium)

(set-face-attribute 'fixed-pitch nil
		    :font "Monospace"
		    :weight 'medium)

(set-face-attribute 'font-lock-comment-face nil
		    :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil
		    :slant 'italic)

(add-to-list 'default-frame-alist '(font . "Monospace"))

(setq-default line-spacing 0.12)
#+end_src

** Some settings related to scrolling? 

#+begin_src emacs-lisp
(setq scroll-conservatively 10)
(setq scroll-margin 7)
(setq pixel-scroll-precision-large-scroll-height 40.0)
(setq pixel-scroll-precision-use-momentum t)
#+end_src


* Window configuration system

System to allow saving and loading arbitrary arrangements of buffers easily.

#+begin_src emacs-lisp
(defvar saved-window-configurations '())
#+end_src

This may or may not be necessary somewhere, i don't remember.

#+begin_src emacs-lisp
(use-package subr-x :ensure nil)
#+end_src

#+begin_src emacs-lisp
(defun wcs--format-window-list ()
  (let ((window-list-string-formatted) (value))
    (dolist (window (window-list) value)
      (setq window-list-string-formatted (concat
					  window-list-string-formatted
					  (format "%s, " (buffer-name (window-buffer window))))))
    (setq window-list-string-formatted (string-remove-suffix ", " window-list-string-formatted))
    window-list-string-formatted))
#+end_src

#+begin_src emacs-lisp
(defun save-current-window-configuration (&optional name)
  "Add `current-window-configuration` to saved window configurations, if NAME is provided, give it a name."
  (interactive)
  (add-to-list 'saved-window-configurations `(,(or name
						   (if (string= (projectile-project-name) "-")
						       (format "%s (%s)"
							       (shell-command-to-string "date \"+%a %R\"")
							       (wcs--format-window-list))
						     (format "%s: %s (%s)"
							     (projectile-project-name)
							     (shell-command-to-string "date \"+%a %R\"")
							     (wcs--format-window-list))))
					      . ,(current-window-configuration))))
#+end_src

#+begin_src emacs-lisp
(defun new-window-configuration ()
  "Save the current window configuration, create a new window and close every other window."
  (interactive)
  (save-current-window-configuration)
  (select-window (split-window))
  (delete-other-windows))
#+end_src

#+begin_src emacs-lisp
(defun load-a-saved-window-configuration ()
  "Select a window configuration from the list."
  (interactive)
  (let ((config (cdr
		 (assoc
		  (completing-read "Select a window configuration: " saved-window-configurations)
		  saved-window-configurations))))
    (if config
	(set-window-configuration config)
      (message "Selected item is invalid, something has gone wrong."))))
#+end_src

#+begin_src emacs-lisp
(defun delete-from-saved-window-configurations ()
  "Select a window configuration to delete."
  (interactive)
  (setq saved-window-configurations
	(delq (assoc
	       (completing-read "Delete a window configuration: "
				saved-window-configurations)
	       saved-window-configurations)
	      saved-window-configurations)))
#+end_src


* Misc functions

This is defined here so i can hook it easily.

#+begin_src emacs-lisp
(defun th/turn-off-line-numbers ()
  "Turn off line numbers ðŸ¤¯"
  (display-line-numbers-mode 0))
#+end_src

Function to make mode keymaps easier, there's no real point to this.

#+begin_src emacs-lisp
(defun make-mode-keymap (map outer)
  (mapc (lambda (inner)
	  (define-key map (kbd (car inner)) (cdr inner)))
	outer))
#+end_src

This is bound to =gc= in normal mode

#+begin_src emacs-lisp
(defun comment-or-uncomment-region-or-line ()
  "If a region is selected, either uncomment or comment it, if not, uncomment or comment the current line."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      ;; else
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))
#+end_src

This is bound to =SPC er=

#+begin_src emacs-lisp
(defun eval-region-and-go-to-normal-mode ()
  "Evaluate elisp in the selected region, and go back to normal mode."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      ;; else
      (setq beg (line-beginning-position) end (line-end-position)))
    (eval-region beg end)
    (evil-normal-state)))
#+end_src

Intelligently split windows

#+begin_src emacs-lisp
(defun th/intelligent-split (&optional force)
  (interactive)
  (let ((width (window-total-width))
	(height (window-total-height)))
    (cond ((and (< width 140) (< height 40) (not force)) (current-buffer))
	  ((> (+ 10 (* 2 height)) width) (split-window-below))
	  (t (split-window-right)))))
#+end_src

* Keybinding

** Evil mode and prerequisites

Undo system for evil mode, i don't really have a point for using undo-tree specifically, but it looked cool so i picked it.

#+begin_src emacs-lisp
(use-package undo-tree
  :diminish undo-tree-mode
  :diminish global-undo-tree-mode
  :config
  (global-undo-tree-mode)
  (defvar th/undo-tree-dir (expand-file-name "undo-tree/" user-emacs-directory))
  (unless (file-directory-p th/undo-tree-dir)
    (make-directory th/undo-tree-dir))
  (defadvice undo-tree-make-history-save-file-name
      (after undo-tree activate)
    (setq ad-return-value (concat th/undo-tree-dir ad-return-value))))
#+end_src

Vi(m) bindings in emacs

#+begin_src emacs-lisp
(use-package evil
  :after undo-tree
  :demand t
  :custom
  (evil-want-integration t)
  (evil-want-keybinding nil)
  (evil-vsplit-window-right t)
  (evil-split-window-below t)
  (evil-undo-system 'undo-tree)
  :config
  (evil-set-undo-system evil-undo-system)
  (evil-mode))
#+end_src

** Evil mode improvements

Collection of evil-like bindings for other modes.

#+begin_src emacs-lisp
(use-package evil-collection
  :demand t
  :after evil
  :diminish evil-collection-unimpaired-mode
  :config
  (evil-collection-init '(dashboard
			  woman
			  pdf
			  org
			  dired
			  elfeed
			  ediff
			  eshell
			  wdired
			  emoji
			  image
			  ibuffer
			  simple-mpc
			  magit
			  vterm)))
#+end_src

j and k go down visual lines, not real lines

#+begin_src emacs-lisp
(use-package evil-better-visual-line
  :demand t
  :after evil
  :config
  (evil-better-visual-line-on))
#+end_src

** general.el

Which key

#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :diminish which-key-mode
  :config
  (which-key-setup-side-window-bottom)
  (which-key-mode))
#+end_src

#+begin_src emacs-lisp
(use-package general
  :demand t
  :config
  (general-evil-setup))

;; (general-create-definer th/leader
;;   :states '(normal insert visual emacs motion)
;;   :keymaps 'override
;;   :prefix "SPC"
;;   :global-prefix "C-SPC")

;; (general-create-definer th/local
;;   :states '(normal insert visual emacs motion)
;;   :keymaps 'override
;;   :prefix "SPC l"
;;   :global-prefix "C-SPC l")

(general-def :keymaps 'override
  "M-x" 'execute-extended-command)

(general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
  "w" '(:ignore t :wk "window")
  "wh" '(windmove-left :wk "move left")
  "wj" '(windmove-down :wk "move down")
  "wk" '(windmove-up :wk "move up")
  "wl" '(windmove-right :wk "move right")
  "<left>" '(windmove-left :wk "move left")
  "<down>" '(windmove-down :wk "move down")
  "<up>" '(windmove-up :wk "move up")
  "<right>" '(windmove-right :wk "move right")
  "wq" '(evil-quit :wk "close")
  "ww" '(evil-quit :wk "close")
  "ws" '((lambda () (interactive) (th/intelligent-split t)) :wk "horizontal split")

  "wc" '(:ignore t :wk "window configurations")
  "wcl" '(load-a-saved-window-configuration :wk "load")
  "wcs" '(save-current-window-configuration :wk "save")
  "wcn" '(new-window-configuration :wk "new")
  
  "H" '((lambda () (interactive) (evil-window-increase-width 2)) :wk "increase window width")
  "J" '((lambda () (interactive) (evil-window-increase-height 2)) :wk "increase window height")
  
  "l" '(:ignore t :wk "local (mode specific)")
  "s" '(:ignore t :wk "search")

  "d" '((lambda () (interactive)
	  (when default-directory
	    (select-window (th/intelligent-split))
	    (dired default-directory))) :wk "dired")

  "o" '(:ignore t :wk "open")

  ":" '(execute-extended-command :wk "M-x")
  ";" '(execute-extended-command :wk "M-x")
  "." '(find-file :wk "find file")
  ">" '((lambda () (interactive) (find-file nil (getenv "HOME"))) :wk "find file from ~/")
  
  "h" '(:ignore t :wk "help")
  "hb" '(describe-bindings t :wk "describe binding")
  "hf" '(describe-function t :wk "describe function")
  "hv" '(describe-variable t :wk "describe variable")
  "ha" '(apropos :wk "describe variable")
  
  "b" '(:ignore t :wk "buffer")
  "bi" '(ibuffer :wk "ibuffer")
  "bK" '(kill-buffer :wk "kill buffer")
  "bk" '(kill-current-buffer :wk "kill this buffer")

  "e" '(:ignore t :wk "emacs")
  "er" '(eval-region-and-go-to-normal-mode :wk "eval region or line")
  "eb" '(eval-buffer :wk "eval buffer")
  "ee" '(eval-expression :wk "eval expression"))

(general-define-key
 :states '(normal visual)
 "gc" 'comment-or-uncomment-region-or-line
 "<up>" 'enlarge-window
 "<left>" 'shrink-window-horizontally
 "<right>" 'enlarge-window-horizontally
 "<down>" 'shrink-window
 ";" 'evil-ex
 "C-k" 'enlarge-window
 "C-h" 'shrink-window-horizontally
 "C-l" 'enlarge-window-horizontally
 "C-j" 'shrink-window)

(general-define-key
 "C-=" 'text-scale-increase
 "C--" 'text-scale-decrease
 "<escape>" #'keyboard-quit
 "<escape>" #'keyboard-escape-quit
 "ESC" #'keyboard-quit
 "ESC" #'keyboard-escape-quit
 "<C-wheel-up>" 'text-scale-increase
 "<C-wheel-down>" 'text-scale-decrease)
#+end_src

#+RESULTS:


* Org mode

** Org itself

#+begin_src emacs-lisp :tangle no
(defun th/agenda-category ()
  (let* ((file-name (when buffer-file-name
		      (file-name-sans-extension
		       (file-name-nondirectory))))
	 (title (org-get-title))
	 (category (org-get-category)))
    (or (if (and
	     title
	     (string= category file-name))
	    title
	  category)
	"")))
#+end_src

#+begin_src emacs-lisp
(use-package org
  :demand t
  :mode ("\\.org\\'" . org-mode)
  :diminish org-indent-mode
  :custom
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively t)
  (org-startup-with-inline-images t)
  :init
  (add-hook 'org-mode-hook #'org-indent-mode)
  (add-hook 'org-mode-hook (lambda () (electric-indent-local-mode -1)))
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
	   "oa" '(org-agenda :wk "org agenda"))
  (:states '(normal visual motion) :keymaps 'org-mode-map :prefix "SPC l"
    "l" '(:ignore t :wk "org link")
    "li" '(org-insert-link :wk "insert org link")
    "lo" '(org-open-at-point :wk "open org link")
    "le" '(org-edit-special :wk "open org link")
    "lt" '(org-toggle-link-display :wk "toggle link display"))
  (:keymaps 'org-mode-map :states '(normal visual motion)
	    "RET" (lambda () (interactive)
		    (unless (ignore-errors (org-open-at-point))
		      (evil-ret)))))
#+end_src

#+begin_src emacs-lisp
(setq calendar-week-start-day 1)
#+end_src

** Org roam

Note taking

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :demand t
  :init
  (setq org-roam-directory (file-truename "~/Documents/org/roam"))
  (unless (file-directory-p org-roam-directory)
    (make-directory org-roam-directory))
  :config
  (org-roam-db-autosync-mode)
  (org-roam-setup)
  (setq org-agenda-files (org-roam-list-files))
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "r" '(:ignore t :wk "roam")
    "rb" '(org-roam-buffer-toggle :wk "buffer")
    "rf" '(org-roam-node-find :wk "find node")
    "rI" '(org-id-get-create :wk "create id")
    "ri" '(org-roam-node-insert :wk "insert node")))
#+end_src

** Org download

Allow easily inserting images

#+begin_src emacs-lisp
(use-package org-download
  :after org
  :demand t
  :hook (dired-mode . org-download-enable)
  :custom (org-download-screenshot-method "grim -g \"$(slurp)\" -t png %s")
  :general
  (:states '(normal visual motion) :keymaps 'org-mode-map :prefix "SPC l"
    "s" '(org-download-screenshot :wk "screenshot")
    "c" '(org-download-clipboard :wk "image from clipboard")))
#+end_src

** Org tempo

Faster inserting of templates like the source code blocks here.

#+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil ;; included with org
  :after org
  :demand t
  :config
  (setq org-structure-template-alist (cons '("el" . "src emacs-lisp") org-structure-template-alist))
  (setq org-structure-template-alist (cons '("fnl" . "src fennel") org-structure-template-alist)))
#+end_src

** Org bullets

#+begin_src emacs-lisp
(use-package org-bullets
  :diminish org-bullets-mode
  :hook (org-mode . org-bullets-mode))
#+end_src

** Olivetti

#+begin_src emacs-lisp
(use-package olivetti
  :after org
  :diminish olivetti-mode
  :init (setq olivetti-min-body-width 50
	      olivetti-body-width 80
	      olivetti-style 'fancy
	      olivetti-margin-width 12)
  :config
  (set-face-attribute 'olivetti-fringe nil :background "#313244")
  :hook
  (olivetti-mode-on . (lambda () (olivetti-set-width olivetti-body-width)))
  (org-mode . olivetti-mode))
#+end_src


* IDE

** Project management

*** Git

#+begin_src emacs-lisp
(use-package magit
  :init
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1
	magit-auto-revert-mode nil)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "g" '(:ignore t :wk "git")
    "gg" '(magit-status :wk "open magit")
    "gd" '(:ignore t :wk "diff")
    "gdu" '(magit-diff-unstaged :wk "diff unstaged")
    "gds" '(magit-diff-staged :wk "diff staged")
    "gc" '(magit-commit-create :wk "commit")))
#+end_src

Show added/deleted/edited parts in the fringe

#+begin_src emacs-lisp
(defun th/configure-git-gutter-mode-faces ()
  (set-face-background 'git-gutter+-added "green")
  (set-face-background 'git-gutter+-modified "purple")
  (set-face-background 'git-gutter+-deleted "red"))

(use-package git-gutter-fringe+
  :commands (git-gutter+mode)
  :diminish git-gutter+-mode
  :hook
  (prog-mode . git-gutter+-mode)
  (git-gutter+-mode . th/configure-git-gutter-mode-faces)
  (olivetti-mode-on . git-gutter+-toggle-fringe)
  :general
  (:states '(normal visual motion) :keymaps 'git-gutter+-mode-map :prefix "SPC"
    "gs" '(git-gutter+-show-hunk :wk "stage hunks")
    "ga" '(git-gutter+-stage-hunks :wk "stage hunks")
    "gr" '(git-gutter+-revert-hunks :wk "stage hunks")
    "gn" '(git-gutter+-next-hunk :wk "next hunk")
    "gN" '(git-gutter+-previous-hunk :wk "previous hunk")))
#+end_src

Git timemachine lets you browse through the history of a file tracked by git

#+begin_src emacs-lisp
(use-package git-timemachine
  :general-config
  (general-define-key
   :states 'normal
   :keymaps 'git-timemachine-mode-map
   "<" 'git-timemachine-show-previous-revision
   "J" 'git-timemachine-show-previous-revision
   ">" 'git-timemachine-show-next-revision
   "K" 'git-timemachine-show-next-revision
   "i" nil ;; no point in going to insert mode, the buffer is read only
   "C-f" (lambda () (git-timemachine-show-nth-revision 1))
   "C-g" 'git-timemachine-show-nth-revision
   "C-c" 'git-timemachine-show-current-revision)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "gt" '(git-timemachine-toggle :wk "git timemachine")))
#+end_src

*** Projectile

Projectile is a project management tool for emacs

#+begin_src emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :defer t
  :custom
  (projectile-switch-project-action #'projectile-dired)
  :config
  (projectile-mode)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "P" '(:keymap projectile-command-map :package projectile)
    "p" '(:ignore t :package projectile :wk "project")
    "pp" '(projectile-switch-project :wk "switch project")
    "ps" '((lambda () (interactive) (consult-ripgrep (projectile-project-root))) :wk "search project")
    "p." '(projectile-find-file :wk "find project file")
    "po" '(:ignore t :wk "open")
    "pog" '(projectile-vc :wk "project version control (git)")
    "pb" '(projectile-switch-to-buffer :wk "switch buffer in project")))
#+end_src

Sort ibuffer by project

#+begin_src emacs-lisp
(use-package ibuffer-projectile
  :config
  (add-hook 'ibuffer-hook (lambda ()
			    (ibuffer-projectile-set-filter-groups)
			    (unless (eq ibuffer-sorting-mode 'alphabetic
					(ibuffer-do-sort-by-alphabetic))))))
#+end_src

*** TODO

Highlight the following keywords in code

- =TODO=
- =HACK=
- =FIXME=

#+begin_src emacs-lisp
(use-package hl-todo
  :demand t
  :diminish hl-todo-mode
  :diminish global-hl-todo-mode
  :custom
  (hl-todo-keyword-faces '(("TODO" . "#cc9393")
			   ("HACK" . "#d0bf8f")
			   ("FIXME" . "#cc9393")))
  :config
  (global-hl-todo-mode 1))
#+end_src

Index those keywords inside magit.

#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :hook (magit-mode . magit-todos-mode)
  :config (magit-todos-mode 1))
#+end_src

** Lsp

#+begin_src emacs-lisp
(use-package eglot
  :demand t
  :custom
  (eglot-autoshutdown t)
  :config
  (fset #'jsonrpc--log-event #'ignore)
  (setq eglot-events-buffer-size 0
	eglot-sync-connect nil
	eglot-connect-timeout nil)
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "c" '(:ignore t :wk "code")
    "ca" ("code actions" . (lambda () (interactive)
			     (eglot-code-actions 1 (point-max) nil t)))))
#+end_src

#+begin_src emacs-lisp
(use-package eglot-booster
  :after eglot
  :config (eglot-booster-mode))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck
  :demand t
  :config 
  (global-flycheck-mode)
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "cn" '(flycheck-next-error :wk "next error")
    "cN" '(flycheck-previous-error :wk "previous error")))
#+end_src

#+begin_src emacs-lisp
(use-package flycheck-eglot
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
#+end_src

** Formatting

#+begin_src emacs-lisp
(use-package apheleia
  :demand t
  :diminish apheleia
  :config
  (setf (alist-get 'nixfmt apheleia-formatters)
	'("alejandra"))
  (apheleia-global-mode +1))
#+end_src

** Completion

Corfu wip

#+begin_src emacs-lisp
(use-package corfu
  :demand t
  :custom
  (corfu-auto t)
  (corfu-auto-delay 0.18)
  (corfu-cycle t)
  :hook
  (after-init . global-corfu-mode)
  :config
  (make-mode-keymap corfu-mode-map '(("C-j" . nil)
				     ("C-k" . nil)))
  
  (make-mode-keymap corfu-map '(("RET" . nil)
				("<up>" . nil)
				("<down>" . nil)
				("C-j" . corfu-next)
				("C-k" . corfu-previous)
				("S-RET" . corfu-complete)
				("S-<return>" . corfu-complete))))
#+end_src

** Languages

Language specific setup

*** Rust

#+begin_src emacs-lisp
(use-package rustic
  :after eglot
  :diminish rustic-mode
  :mode ("\\.rs\\'" . rustic-mode)
  :hook (rustic-mode . eglot-ensure)
  :init
  (setq rustic-lsp-client 'eglot
	rustic-use-rust-save-some-buffers t
	compilation-ask-about-save nil))
#+end_src

*** Nix

#+begin_src emacs-lisp
(use-package nix-mode
  :after eglot
  :mode "\\.nix\\'"
  :hook (nix-mode . eglot-ensure))
#+end_src

*** Haskell

#+begin_src emacs-lisp
(use-package haskell-mode
  :after eglot
  :mode "\\.hs\\'"
  :hook (haskell-mode . eglot-ensure))
#+end_src

*** Lua

#+begin_src emacs-lisp
(use-package lua-mode
  :after eglot
  :mode "\\.lua\\'"
  :hook (lua-mode . eglot-ensure))
#+end_src

*** Gdscript/godot

#+begin_src emacs-lisp
(use-package gdscript-mode
  :after eglot
  :mode "\\.gdscript\\'"
  :hook (gdscript-mode . eglot-ensure))
#+end_src

*** Fennel

Fennel is a nice lispy language, with lua compatibility

#+begin_src emacs-lisp
(use-package fennel-mode
  :after eglot
  :mode "\\.fnl\\'"
  :hook (fennel-mode . eglot-ensure)
  :init
  (add-to-list 'eglot-server-programs '(fennel-mode . ("fennel-ls")))
  ;; :init
  ;; (add-to-list 'lsp-language-id-configuration '(fennel-mode . "fennel"))
  ;; (lsp-register-client (make-lsp-client
  ;; 			:new-connection (lsp-stdio-connection "fennel-ls")
  ;; 			:activation-fn (lsp-activate-on "fennel")
  ;; 			:server-id 'fennel-ls))
  )
#+end_src

Org src blocks in fennel

#+begin_src emacs-lisp
(use-package ob-fennel
  :ensure nil ;; part of fennel-mode
  :after org)
#+end_src

*** Janet

#+begin_src emacs-lisp
(use-package janet-mode
  :after eglot
  :mode "\\.janet\\'")
#+end_src

*** C#

#+begin_src emacs-lisp
(use-package csharp-mode
  :after eglot
  :mode "\\.cs\\'"
  :hook
  (csharp-mode . eglot-ensure)
  (csharp-mode . csharp-ts-mode))
#+end_src

*** Elisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'corfu-mode)
#+end_src

** Misc nice things

Smartparens-mode allows you to use parenthesis and some other characters more easily.

#+begin_src emacs-lisp
(use-package smartparens
  :demand t
  :diminish smartparens-mode
  :config
  (smartparens-global-mode))
#+end_src

Rainbow delimiters gives colors to delimiters like parenthesis, which helps with seeing where you are at, especially in lisp land.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :diminish rainbow-delimiters-mode
  :hook
  (prog-mode . rainbow-delimiters-mode)
  (org-mode . rainbow-delimiters-mode))
#+end_src



* Terminals 

** Vterm

Vterm is a full fledged terminal emulator inside emacs, it should work with any terminal application.

#+begin_src emacs-lisp
(defun th/vterm (&optional projectile)
  (if projectile
      (projectile-run-vterm t)
    (vterm t))
  (end-of-buffer)
  (evil-append-line 1))

(use-package vterm
  :hook (vterm-mode . th/turn-off-line-numbers)
  :commands (vterm)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "ov" '((lambda () (interactive)
	     (select-window (th/intelligent-split))
	     (th/vterm)) :wk "vterm")
    "oV" '((lambda () (interactive)
	     (th/vterm)) :wk "vterm in this window")
    "pov" '((lambda () (interactive)
	     (select-window (th/intelligent-split))
	     (th/vterm t)) :wk "vterm")
    "poV" '((lambda () (interactive)
	     (th/vterm t)) :wk "vterm in this window")))
#+end_src

#+RESULTS:

** Eshell

Eshell is a built in shell, with support for normal system commands, and emacs lisp expressions. It is very powerful and extensible.

Fish-completion allows eshell to use completions from fish.

#+begin_src emacs-lisp
(use-package fish-completion)
#+end_src

Eshell itself

#+begin_src emacs-lisp
(defun th/eshell (&optional projectile &rest args)
  (if projectile
      (projectile-run-eshell t)
    (eshell t))
  (end-of-buffer)
  (evil-append-line 1))

(use-package eshell
  :ensure nil
  :after (fish-completion smartparens)
  :commands (eshell projectile-run-eshell)
  :init
  (setq eshell-history-size 100000)
  :hook
  (eshell-mode . th/turn-off-line-numbers)
  (eshell-mode . smartparens-mode)
  (eshell-mode . fish-completion-mode)
  :general-config
  (general-def :states '(normal visual) :keymaps 'eshell-mode-map
	   "A" (lambda () (interactive) (end-of-buffer) (evil-append-line 1)))
  (general-def :states '(normal visual insert) :keymaps 'eshell-mode-map
    "C->" (lambda () (interactive) 
	    (insert (concat "> #<buffer " (read-buffer "Send to: ") ">")) ))
  :general
  (general-def :keymaps 'eshell-mode-map :states '(normal visual motion)
	    "RET" (lambda () (interactive)
		    (unless (ignore-errors (browse-url))
		      (evil-ret))))
  (general-def :states '(normal visual insert emacs motion) :prefix "SPC" :keymaps 'override :global-prefix "C-SPC"
    "oe" '((lambda () (interactive) 
	     (select-window (th/intelligent-split)) 
	     (th/eshell)) :wk "eshell")'
    "oE" '((lambda () (interactive) (th/eshell)) :wk "eshell in this window")
    "poe" '((lambda () (interactive) 
	      (select-window (th/intelligent-split))
	      (th/eshell t)) :wk "eshell")'
    "poE" '((lambda () (interactive) (th/eshell t)) :wk "eshell in new window")))
#+end_src

#+RESULTS:

Aliases and functions

#+begin_src emacs-lisp
(defun eshell/v (&rest args)
  (select-window (th/intelligent-split))
  (apply 'eshell-exec-visual args))

(defalias 'eshell/V 'eshell-exec-visual)

(defmacro re (&rest rx-sexp) ;; Stolen from https://youtube.com/watch?v=9xLeqwl_7n0
  "Convert rx expression RX-SEXP to pcre compatible regexp."
  `(rxt-elisp-to-pcre (rx ,@rx-sexp)))

(defalias 'eshell/less 'view-file)
#+end_src

For some reason advice-add didn't seem to function, so this just manually replicates eshell/exit.

#+begin_src emacs-lisp
(defun eshell/exit ()
  (evil-quit)
  (throw 'eshell-terminal t))
(defalias 'eshell/e 'eshell/exit)
#+end_src

#+begin_src emacs-lisp
(use-package eshell-vterm
  :demand t
  :after eshell
  :config 
  (eshell-vterm-mode))
#+end_src



* Misc stuff

** Vertico, consult, orderless and marginalia

#+begin_src emacs-lisp
(use-package vertico
  :init
  (setq vertico-resize t)
  :config
  (make-mode-keymap vertico-map '(("C-j" . vertico-next)
				  ("C-k" . vertico-previous)
				  ("C-u" . vertico-quick-exit)
				  ("<backspace>" . vertico-directory-delete-char)
				  ("DEL" . vertico-directory-delete-char)))
  (vertico-mode))
#+end_src

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "sg" '((lambda () (interactive) (consult-ripgrep (expand-file-name ""))) :wk "M-x")
    "sf" '(consult-fd :wk "find")
    "bs" '(consult-buffer :wk "switch")
    "bo" '((lambda () (interactive)
	     (select-window (th/intelligent-split))
	     (consult-buffer)) :wk "open buffer in new window")
    ))
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
(use-package orderless
  :after (vertico consult)
  :init
  (setq completion-styles '(orderless basic)
	completion-category-defaults nil
	completion-category-overrides '((file (styles partial-completion)))))
#+end_src

#+begin_src emacs-lisp
(use-package marginalia
  :config
  (marginalia-mode))
#+end_src

#+begin_src emacs-lisp
(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
		(replace-regexp-in-string
		 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
		 crm-separator)
		(car args))
	(cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)

(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible-mode t face minibuffer-prompt)
      enable-recursive-minibuffers t)

(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

** Popups with popper

Look into replacing this

#+begin_src emacs-lisp :tangle no
(use-package popper
  :demand t
  :init
  (setq popper-reference-buffers
	'("^\\*vterm.*\\*$" vterm-mode
	  "\\*eldoc\\*" vterm-mode
	  ("\\*elpaca-log\\*" . hide)
	  ("\\*rustic.*\\*" . hide)
	  ("\\*rustfmt\\*" . hide)
	  ("\\*rust-analyzer.*\\*" . hide)
	  ("\\*scratch\\*" . hide)
	  ("\\*Warnings\\*" . hide)
	  (compilation-mode . hide))
	popper-group-function #'popper-group-by-projectile
	popper-window-height 20)
  :config
  (popper-mode 1)
  (popper-echo-mode 1)
  :general-config
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC"
    "op" '(:ignore t :wk "popper")
    "opt" '(popper-toggle :wk "popper toggle")
    "opm" '(popper-toggle-type :wk "popper toggle type")
    "opc" '(popper-cycle :wk "popper cycle")))
#+end_src

** LLM

Large language models inside emacs, powered by ollama.

#+begin_src emacs-lisp
(use-package ellama
  :init
  (require 'llm-ollama)
  (setopt ellama-provider
	  (make-llm-ollama
	   :chat-model "llama3.1:8b"
	   :embedding-model "nomic-embed-text"))

  (setopt ellama-providers '(("llama3.1" . (make-llm-ollama
					    :chat-model "llama3.1:8b"
					    :embedding-model "nomic-embed-text"))
			     ("mistral-nemo" . (make-llm-ollama
						:chat-model "mistral-nemo:12b"
						:embedding-model "nomic-embed-text"))
			     ("deepseek-coder-v2" . (make-llm-ollama 
						     :chat-model "deepseek-coder-v2:16b"
						     :embedding-model "nomic-embed-text")))))

(defun eshell/ollama-unload (model)
  (call-process-shell-command 
   (format 
   "curl --silent --show-error http://localhost:11434/api/generate -d '{\"model\": \"%s\", \"keep_alive\":0}'" model)))
#+end_src

** Elfeed

#+begin_src emacs-lisp
(use-package elfeed
  :custom
  (elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory))
  (elfeed-enclosure-default-dir user-emacs-directory)
  (elfeed-feeds '("https://howardism.org/index.xml" 
		  "https://xenodium.com/rss.xml"
		  "https://xeiaso.net/blog.rss"
		  "https://jade.fyi/rss.xml")))
#+end_src

#+RESULTS:

** Media playback "inside" emacs

#+begin_src emacs-lisp
(general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
  "m" '(:ignore t :wk "media"))
#+end_src

Control mpd from emacs

#+begin_src emacs-lisp
(use-package simple-mpc
  :hook (simple-mpc-mode . th/turn-off-line-numbers)
  :general
  (:states '(normal visual motion) :keymaps 'override :prefix "SPC" 
    "m" '(:ignore t :wk "media")
    "mm" '(simple-mpc :wk "open simple-mpc")
    "ms" '(simple-mpc-query :wk "search")
    "mp" '(simple-mpc-toggle :wk "play/pause")
    "mC" '(simple-mpc-clear-current-playlist :wk "clear")
    "mP" '(simple-mpc-view-current-playlist :wk "playlist")
    "ma" '(simple-mpc-load-playlist :wk "load playlist")
    "mh" '(simple-mpc-prev :wk "prev")
    "ml" '(simple-mpc-next :wk "next")))
#+end_src

Control an mpv instance inside emacs

#+begin_src emacs-lisp
(use-package empv
  :init (setq empv-invidious-instance "https://iv.nowhere.moe/api/v1"))

(defun eshell/yt (&rest args)
  (empv-youtube (mapconcat (lambda (s) (format "%s " s)) args)))
#+end_src

** Separedit

Separedit allows you to edit a part of a buffer in another buffer, and use another major mode that way, a bit like org src blocks, but worse.

#+begin_src emacs-lisp
(use-package separedit)
#+end_src

** Fix/improve some emacs stuff

*** Tramp

Tramp doesn't work properly on nixos systems by default, because it doesn't find $PATH

#+begin_src emacs-lisp
(use-package tramp-sh
  :ensure nil ;; part of emacs
  :config
  (setq tramp-remote-path
	(append tramp-remote-path
 		'(tramp-own-remote-path))))
#+end_src

*** Dired

#+begin_src emacs-lisp
(use-package dired
  :ensure nil
  :demand t
  :init (setq dired-listing-switches "-alh")
  :general-config
  (:keymaps 'dired-mode-map :states '(normal insert visual motion)
    "SPC" nil
    "q" 'evil-quit
    "<backspace>" 'dired-up-directory)
  (:keymaps 'dired-mode-map :states '(normal visual motion) :prefix "SPC"
    "oe" '((lambda () (interactive) (th/eshell)) :wk "eshell in this window"))
  :config
  (unless (display-graphic-p)
    (general-def dired-mode-map "DEL" 'dired-up-directory)))
#+end_src

Casual dired has magit-like menus for dired commands

#+begin_src emacs-lisp :tangle no
(use-package casual-dired
  :general
  (:keymaps dired-mode-map
	    "C-o" 'casual-dired-tmenu))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package openwith
  :custom
  (openwith-associations '((rx nonl
			       (or ".mkv"
				   ".mp4"
				   ".webm"
				   ".mp3"
				   ".opus"
				   ".ogg"
				   ".flac"))
			   "mpv" (file))))
#+end_src

* Theming

This function will only execute a given function on the first server frame creation.

#+begin_src emacs-lisp
(defvar th/first-server-frame-created nil)
(defun th--unless-first-server-frame-created (func)
  (unless th/first-server-frame-created
    (funcall func)
    (setq th/first-server-frame-created t)))
#+end_src

*** Catppuccin

#+begin_src emacs-lisp
(use-package catppuccin-theme
  :init
  (setq catppuccin-flavor 'mocha)
  :hook
  (after-init . catppuccin-reload)
  (server-after-make-frame . (lambda () (when (display-graphic-p)
					  (th--unless-first-server-frame-created 'catppuccin-reload)))))
#+end_src

*** Solaire

Solaire mode darkens "lesser" buffers like eshell or magit

#+begin_src emacs-lisp
(use-package solaire-mode
  :hook
  (after-init . (lambda ()
		  (when (display-graphic-p) (solaire-global-mode +1))))
  (server-after-make-frame . (lambda ()
			       (when (display-graphic-p) (solaire-global-mode +1)))))
#+end_src

** All the icons

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

*** Dired

#+begin_src emacs-lisp
(defun th--ati-dired ()
  (when (display-graphic-p)
    (th--unless-first-server-frame-created
     (lambda () (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)))))
(use-package all-the-icons-dired
  :after all-the-icons
  :diminish all-the-icons-dired-mode
  :hook
  (after-init . (lambda ()
		  (when (display-graphic-p) (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))))
  (server-after-make-frame . th--ati-dired))
#+end_src

*** Ibuffer

#+begin_src emacs-lisp
(defun th--ati-ibuffer ()
  (when (display-graphic-p)
    (th--unless-first-server-frame-created
     (lambda () (add-hook 'ibuffer-mode-hook #'all-the-icons-ibuffer-mode)))))
(use-package all-the-icons-ibuffer
  :after all-the-icons
  :diminish all-the-icons-ibuffer-mode
  :hook
  (after-init . (lambda ()
		  (when (display-graphic-p) (add-hook 'ibuffer-mode-hook #'all-the-icons-ibuffer-mode))))
  (server-after-make-frame . th--ati-ibuffer))
#+end_src

* EXWM

#+begin_src emacs-lisp
(when (getenv "EMACS_ENABLE_EXWM")
  (setq mouse-autoselect-window t
	follow-focus-mouse t)

  (use-package dmenu
    :demand t)

  (use-package dwm-workspaces)

  (use-package exwm
    :after (dmenu dwm-workspaces)
    :demand t
    :config
    (when (executable-find "wmctrl")
      (unless (eq (call-process "wmctrl" nil nil nil "-m") 0)
	(progn
	  (require 'exwm-config)
	  (require 'exwm-randr)
	  (require 'exwm-systemtray)
	  (require 'exwm-xim)

	  (dwm-workspaces--init)

	  (defun th/exwm-shell-cmd (command) (start-process-shell-command (car (split-string command " ")) nil command))

	  (mapc 'th/exwm-shell-cmd
		'("xset r rate 300 50"
		  "dbus-update-activation-environment --verbose --systemd DBUS_SESSION_BUS_ADDRESS DISPLAY XAUTHORITY &"))

	  (when (file-directory-p "/sys/class/power_supply/BAT0/")
	    (display-battery-mode))

	  (setq display-time-format "%H:%M:%S - %d %b %Y (%a)"
		display-time-default-load-average nil)
	  (display-time-mode 1)

	  (setq exwm-input-line-mode-passthrough t)

          (dolist (k `(
                       escape
                       ))
            (cl-pushnew k exwm-input-prefix-keys))

	  
	  (defun advice-exwm-input--on-ButtonPress-line-mode (buffer button-event)
	    "Handle button events in line mode.
BUFFER is the `exwm-mode' buffer the event was generated
on. BUTTON-EVENT is the X event converted into an Emacs event.

The return value is used as event_mode to release the original
button event."
	    (with-current-buffer buffer
	      (let ((read-event (exwm-input--mimic-read-event button-event)))
		(exwm--log "%s" read-event)
		(if (and read-event
			 (exwm-input--event-passthrough-p read-event))
		    ;; The event should be forwarded to emacs
		    (progn
		      (exwm-input--cache-event read-event)
		      (exwm-input--unread-event button-event)

		      xcb:Allow:ReplayPointer)
		  ;; The event should be replayed
		  xcb:Allow:ReplayPointer))))

	  (advice-add 'exwm-input--on-ButtonPress-line-mode :override #'advice-exwm-input--on-ButtonPress-line-mode)
	  
	  (setq exwm-input-global-keys
		`((,(kbd "s-i") . exwm-input-toggle-keyboard)
		  (,(kbd "s-d") . dmenu)
		  (,(kbd "s-SPC") . ,(lambda () (interactive) (toggle-input-method)))
		  (,(kbd "<XF86AudioPlay>") . simple-mpc-toggle)
		  (,(kbd "<XF86AudioRaiseVolume>") . ,(lambda () (interactive) (th/exwm-shell-cmd "wpctl set-volume -l 1.5 @DEFAULT_AUDIO_SINK@ 3%+")))
		  (,(kbd "<XF86AudioLowerVolume>") . ,(lambda () (interactive) (th/exwm-shell-cmd "wpctl set-volume @DEFAULT_AUDIO_SINK@ 3%-")))
		  
		  (,(kbd "M-x") . execute-extended-command)

		  (,(kbd "s-,") . dwm-workspaces--select-previous-monitor)
		  (,(kbd "s-.") . dwm-workspaces--select-next-monitor)

		  (,(kbd "s-1") . (lambda () (interactive) (dwm-workspaces--switch-by-index 1)))
		  (,(kbd "s-2") . (lambda () (interactive) (dwm-workspaces--switch-by-index 2)))
		  (,(kbd "s-3") . (lambda () (interactive) (dwm-workspaces--switch-by-index 3)))
		  (,(kbd "s-4") . (lambda () (interactive) (dwm-workspaces--switch-by-index 4)))
		  (,(kbd "s-5") . (lambda () (interactive) (dwm-workspaces--switch-by-index 5)))
		  (,(kbd "s-6") . (lambda () (interactive) (dwm-workspaces--switch-by-index 6)))
		  (,(kbd "s-7") . (lambda () (interactive) (dwm-workspaces--switch-by-index 7)))
		  (,(kbd "s-8") . (lambda () (interactive) (dwm-workspaces--switch-by-index 8)))
		  (,(kbd "s-9") . (lambda () (interactive) (dwm-workspaces--switch-by-index 9)))
		  (,(kbd "s-1") . (lambda () (interactive) (dwm-workspaces--switch-by-index 1)))
		  (,(kbd "s-2") . (lambda () (interactive) (dwm-workspaces--switch-by-index 2)))
		  (,(kbd "s-3") . (lambda () (interactive) (dwm-workspaces--switch-by-index 3)))
		  (,(kbd "s-4") . (lambda () (interactive) (dwm-workspaces--switch-by-index 4)))
		  (,(kbd "s-5") . (lambda () (interactive) (dwm-workspaces--switch-by-index 5)))
		  (,(kbd "s-6") . (lambda () (interactive) (dwm-workspaces--switch-by-index 6)))
		  (,(kbd "s-7") . (lambda () (interactive) (dwm-workspaces--switch-by-index 7)))
		  (,(kbd "s-8") . (lambda () (interactive) (dwm-workspaces--switch-by-index 8)))
		  (,(kbd "s-9") . (lambda () (interactive) (dwm-workspaces--switch-by-index 9)))

		  (,(kbd "s-!") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 1)))
		  (,(kbd "s-@") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 2)))
		  (,(kbd "s-#") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 3)))
		  (,(kbd "s-$") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 4)))
		  (,(kbd "s-%") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 5)))
		  (,(kbd "s-^") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 6)))
		  (,(kbd "s-&") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 7)))
		  (,(kbd "s-*") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 8)))
		  (,(kbd "s-(") . (lambda () (interactive) (dwm-workspaces--move-window-by-index 9)))

                  ;; ,@(mapc (lambda (i)
                  ;;           `(,(kbd (format "s-%d" i)) .
                  ;;             (lambda () (interactive)
                  ;;               (dwm-workspaces--switch-by-index ,i))))
                  ;;         (number-sequence 1 9))
                  ;; ,@(cl-mapcar (lambda (c n)
                  ;;                `(,(kbd (format "s-%c" c)) .
                  ;;                  (lambda () (interactive)
                  ;;                    (dwm-workspaces--move-window-by-index ,n))))
                  ;;              '(?! ?@ ?# ?$ ?% ?^ ?& ?* ?\()
                  ;;              (number-sequence 1 9))
		  ))
	  
	  (mapc (lambda (keybind)
		  (global-set-key (car keybind) (cdr keybind)))
		exwm-input-global-keys)

	  ;; https://github.com/minad/corfu/discussions/408
          (defun get-focused-monitor-geometry ()
            "Get the geometry of the monitor displaying the selected frame in EXWM."
            (let* ((monitor-attrs (frame-monitor-attributes))
                   (workarea (assoc 'workarea monitor-attrs))
                   (geometry (cdr workarea)))
              (list (nth 0 geometry) ; X
                    (nth 1 geometry) ; Y
                    (nth 2 geometry) ; Width
                    (nth 3 geometry) ; Height
                    )))

	  (defun advise-corfu-make-frame-with-monitor-awareness (orig-fun frame x y width height buffer)
	    "Advise `corfu--make-frame` to be monitor-aware, adjusting X and Y according to the focused monitor."

	    ;; Get the geometry of the currently focused monitor
	    (let* ((monitor-geometry (get-focused-monitor-geometry))
		   (monitor-x (nth 0 monitor-geometry))
		   (monitor-y (nth 1 monitor-geometry))
		   ;; You may want to adjust the logic below if you have specific preferences
		   ;; on where on the monitor the posframe should appear.
		   ;; Currently, it places the posframe at its intended X and Y, but ensures
		   ;; it's within the bounds of the focused monitor.
		   (new-x (+ monitor-x x))
		   (new-y (+ monitor-y y)))

	      ;; Call the original function with potentially adjusted coordinates
	      (funcall orig-fun frame new-x new-y width height buffer)))

	  (advice-add 'corfu--make-frame :around #'advise-corfu-make-frame-with-monitor-awareness)


	  (general-def :states '(normal visual motion) :keymaps 'override :prefix "SPC"
	    ;; remap SPC bs to the exwm switch buffer function
	    ;; "bs" '(exwm-workspace-switch-to-buffer :wk "switch buffer")
	    "y" '(:ignore t :wk "exwm")
	    "yd" '(dmenu :wk "dmenu")
	    "yf" '(exwm-floating-toggle-floating :wk "toggle floating"))

	  (general-define-key 
	   :states '(normal visual visual replace motion emacs operator-pending)
	   :keymaps 'exwm-mode-map
	   "<mouse-1>" (lambda () (interactive) (exwm-input--fake-key 'down))
	   "<mouse-2>" nil
	   "<mouse-3>" nil
	   "<down-mouse-1>" nil
	   "<down-mouse-2>" nil
	   "<down-mouse-3>" nil

	   ;; "i" 'exwm-input-release-keyboard
	   
	   "h" (lambda () (interactive) (exwm-input--fake-key 'left))
	   "j" (lambda () (interactive) (exwm-input--fake-key 'down))
	   "k" (lambda () (interactive) (exwm-input--fake-key 'up))
	   "l" (lambda () (interactive) (exwm-input--fake-key 'right)))

	  (setq exwm-workspace-warp-cursor t
		exwm-layout-show-all-buffers t
		mouse-autoselect-window t
		focus-follows-mouse t)

	  (setq ibuffer-saved-filter-groups
		'(("default"
		   ("Process" (mode . comint-mode))
		   )))

	  (add-hook 'ibuffer-mode-hook
		    (lambda ()
		      (ibuffer-switch-to-saved-filter-groups "default")))

	  (add-hook 'exwm-update-class-hook
		    (lambda ()
		      (if exwm-class-name
			  (exwm-workspace-rename-buffer exwm-class-name)
			(exwm-workspace-rename-buffer (generate-new-buffer-name "EXWM - Unknown window")))
		      (exwm-workspace-rename-buffer (format "EXWM - %s" exwm-class-name))))

	  (exwm-xim-enable)
	  (exwm-randr-enable)
	  (exwm-enable)
	  (exwm-systemtray-enable)
	  ))))

  (use-package exwm-firefox-evil
    :config
    (add-hook 'exwm-manage-finish-hook #'exwm-firefox-evil-activate-if-firefox))
  )
#+end_src

* End

# Local Variables:
# olivetti-body-width: 120
# End:
